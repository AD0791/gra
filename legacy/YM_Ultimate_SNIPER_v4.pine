// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0
// Â© Alexandro Disla - YM Ultimate SNIPER v4
// Unified GRA + DeepFlow | YM-Optimized for Low Volatility
// TARGET: 3-7 High-Confluence Trades per Day
// NEW: Candle-Anchored Imbalance Markers (Continuation/Absorption/Reversal)
// REMOVED: POC (replaced with precise imbalance visualization)

//@version=6
indicator("YM Ultimate SNIPER v4", shorttitle="YMğŸ¯v4", overlay=true, 
     max_labels_count=500, max_boxes_count=500, max_lines_count=500)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  YM-SPECIFIC CONSTANTS  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var float TICK_VALUE = 1.0
var float TICKS_PER_POINT = 1.0

// Time extension constant (milliseconds) - used for extending FVG zones
var int EXTEND_TIME_MS = 1000 * 60 * 60 * 24 * 30  // 30 days in future

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  CONFIGURATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string GRP_YM = "â•â•â•â•â•â•â•â•â•â•â• YM TIER THRESHOLDS â•â•â•â•â•â•â•â•â•â•â•"
float sTierPoints = input.float(50.0, "S-Tier (Points)", minval=20, maxval=150, step=5, group=GRP_YM,
     tooltip="50+ pts = ~$250/contract HOLD (institutional sweep)")
float aTierPoints = input.float(25.0, "A-Tier (Points)", minval=10, maxval=75, step=5, group=GRP_YM,
     tooltip="25-49 pts = ~$125-250/contract SWING (strong momentum)")
float bTierPoints = input.float(12.0, "B-Tier (Points)", minval=5, maxval=30, step=1, group=GRP_YM,
     tooltip="12-24 pts = ~$60-120/contract SCALP (quick grab)")

string GRP_SNIPER = "â•â•â•â•â•â•â•â•â•â•â• SNIPER FILTERS (YM-TUNED) â•â•â•â•â•â•â•â•â•â•â•"
float minVolRatio = input.float(1.8, "Min Volume Ratio", minval=1.3, maxval=3.0, step=0.1, group=GRP_SNIPER,
     tooltip="YM needs 1.8x volume (higher than NQ due to lower retail noise)")
float deltaThreshold = input.float(0.62, "Delta Dominance %", minval=0.55, maxval=0.80, step=0.01, group=GRP_SNIPER,
     tooltip="62%+ = Clear institutional commitment in YM")
float bodyRatio = input.float(0.72, "Min Body Ratio", minval=0.5, maxval=0.9, step=0.02, group=GRP_SNIPER,
     tooltip="72%+ body = Strong conviction (tighter for YM)")
float rangeMultiplier = input.float(1.4, "Min Range vs Avg", minval=1.0, maxval=2.5, step=0.1, group=GRP_SNIPER,
     tooltip="1.4x range = Above-average move in YM")
bool requireCVDConfirm = input.bool(true, "Require CVD Confirmation", group=GRP_SNIPER)
string analysisTimeframe = input.timeframe("1", "Intrabar TF", group=GRP_SNIPER)

string GRP_SESSION = "â•â•â•â•â•â•â•â•â•â•â• SESSION WINDOWS â•â•â•â•â•â•â•â•â•â•â•"
bool onlyKeySession = input.bool(true, "Only Signal in Key Sessions", group=GRP_SESSION)
string sessionTimezone = input.string("America/New_York", "Timezone", 
     options=["America/New_York", "America/Chicago", "Europe/London", "UTC"], group=GRP_SESSION)
string londonWindow = input.string("0300-0500", "London Window", group=GRP_SESSION)
string nyWindow = input.string("0930-1130", "NY Open Window", group=GRP_SESSION)
string nyPowerHour = input.string("1500-1600", "NY Power Hour", group=GRP_SESSION)
bool includePowerHour = input.bool(true, "Include Power Hour", group=GRP_SESSION)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  DEEPFLOW ZONE CONFIGURATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•â•â•â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string GRP_ZONES = "â•â•â•â•â•â•â•â•â•â•â• DEEPFLOW ZONES (YM-TUNED) â•â•â•â•â•â•â•â•â•â•â•"
bool showZones = input.bool(true, "Show FVG Zones", group=GRP_ZONES)
bool showSinglePrints = input.bool(true, "Show Single Print Lines", group=GRP_ZONES)
float minGapATR = input.float(0.25, "Min Gap Size (ATR%)", minval=0.1, maxval=0.8, step=0.05, group=GRP_ZONES)
float zoneImpulseMultiplier = input.float(1.6, "Zone Impulse Multiplier", minval=1.3, maxval=2.5, step=0.1, group=GRP_ZONES)
int maxZoneAge = input.int(75, "Max Zone Age (bars)", minval=30, maxval=150, group=GRP_ZONES)
int maxZones = input.int(12, "Max Active Zones", minval=5, maxval=25, group=GRP_ZONES)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  CANDLE IMBALANCE CONFIGURATION (NEW in v4)  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string GRP_CIMB = "â•â•â•â•â•â•â•â•â•â•â• CANDLE IMBALANCES â•â•â•â•â•â•â•â•â•â•â•"
bool showCandleImb = input.bool(true, "Show Candle Imbalances", group=GRP_CIMB,
     tooltip="Show buy/sell imbalances directly on candles at exact price levels")
float candleImbRatio = input.float(2.0, "Imbalance Ratio", minval=1.5, maxval=4.0, step=0.1, group=GRP_CIMB,
     tooltip="Buy must be 2x sell (or vice versa) to show marker")
int candleImbBins = input.int(8, "Price Resolution", minval=4, maxval=16, step=1, group=GRP_CIMB,
     tooltip="Number of price levels to analyze within each candle")
bool imbOnlyTiered = input.bool(false, "Only on Tiered Candles", group=GRP_CIMB,
     tooltip="Only show imbalances on B-tier and above candles")
bool imbOnlySession = input.bool(true, "Only in Sessions", group=GRP_CIMB)
color buyImbColor = input.color(color.new(#00E676, 0), "Buy Imbalance", group=GRP_CIMB)
color sellImbColor = input.color(color.new(#FF5252, 0), "Sell Imbalance", group=GRP_CIMB)
color absorbColor = input.color(color.new(#FFD700, 0), "Absorption", group=GRP_CIMB)
color reversalColor = input.color(color.new(#E040FB, 0), "Reversal", group=GRP_CIMB)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  HORIZONTAL IMBALANCE ZONES  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string GRP_IMB = "â•â•â•â•â•â•â•â•â•â•â• IMBALANCE S/R ZONES â•â•â•â•â•â•â•â•â•â•â•"
bool showImbZones = input.bool(true, "Show Imbalance S/R Zones", group=GRP_IMB,
     tooltip="Horizontal support/resistance zones from stacked imbalances")
float imbRatio = input.float(2.5, "Min Imbalance Ratio", minval=1.5, maxval=5.0, step=0.1, group=GRP_IMB)
int minStackedLevels = input.int(3, "Min Stacked Levels", minval=2, maxval=6, group=GRP_IMB)
float imbVolFilter = input.float(1.5, "Min Volume for Zone", minval=1.0, maxval=3.0, step=0.1, group=GRP_IMB)
int maxImbZones = input.int(15, "Max Imbalance Zones", minval=5, maxval=30, group=GRP_IMB)
color bullImbZoneColor = input.color(color.new(#00E676, 80), "Bullish Zone", group=GRP_IMB)
color bearImbZoneColor = input.color(color.new(#FF5252, 80), "Bearish Zone", group=GRP_IMB)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  CONFLUENCE SCORING SYSTEM  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string GRP_CONFLUENCE = "â•â•â•â•â•â•â•â•â•â•â• CONFLUENCE SCORING â•â•â•â•â•â•â•â•â•â•â•"
int minConfluenceScore = input.int(5, "Min Confluence Score", minval=3, maxval=8, group=GRP_CONFLUENCE)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  COLOR CONFIGURATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string GRP_COLORS = "â•â•â•â•â•â•â•â•â•â•â• COLORS â•â•â•â•â•â•â•â•â•â•â•"
color sTierColor = input.color(color.new(#FFD700, 0), "S-Tier (Gold)", group=GRP_COLORS)
color aTierColor = input.color(color.new(#00E676, 0), "A-Tier (Green)", group=GRP_COLORS)
color bTierColor = input.color(color.new(#FFC107, 0), "B-Tier (Yellow)", group=GRP_COLORS)
color bullZoneColor = input.color(color.new(#00E676, 75), "Bullish FVG Zone", group=GRP_COLORS)
color bearZoneColor = input.color(color.new(#FF5252, 75), "Bearish FVG Zone", group=GRP_COLORS)
color singlePrintColor = input.color(color.new(#9C27B0, 20), "Single Print", group=GRP_COLORS)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  CANDLE STRUCTURE  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float bodyHigh = math.max(open, close)
float bodyLow = math.min(open, close)
float bodySize = bodyHigh - bodyLow
float candleRange = high - low
float upperWick = high - bodyHigh
float lowerWick = bodyLow - low

float candlePoints = candleRange / TICK_VALUE / TICKS_PER_POINT

bool isBullish = close > open
bool isBearish = close < open

float avgRange = ta.sma(candleRange, 20)
float avgVol = ta.sma(volume, 20)
float volRatio = avgVol > 0 ? volume / avgVol : 1.0
float atr = ta.atr(14)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  SNIPER QUALITY FILTERS  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float currentBodyRatio = candleRange > 0 ? bodySize / candleRange : 0
bool hasStrongBody = currentBodyRatio >= bodyRatio
bool hasSignificantRange = candleRange >= avgRange * rangeMultiplier
bool hasVolume = volRatio >= minVolRatio
bool hasStrongVolume = volRatio >= 2.0

bool bullWickOK = isBullish ? (upperWick < bodySize * 0.5) : true
bool bearWickOK = isBearish ? (lowerWick < bodySize * 0.5) : true
bool wicksOK = bullWickOK and bearWickOK

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  TIER CLASSIFICATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string tier = candlePoints >= sTierPoints ? "S" : candlePoints >= aTierPoints ? "A" : candlePoints >= bTierPoints ? "B" : "X"
bool isTiered = tier != "X"
bool isTierS = tier == "S"
bool isTierA = tier == "A"
bool isTierB = tier == "B"

int tierScore = isTierS ? 3 : isTierA ? 2 : isTierB ? 1 : 0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  SESSION DETECTION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool inLondon = not na(time(timeframe.period, londonWindow, sessionTimezone))
bool inNY = not na(time(timeframe.period, nyWindow, sessionTimezone))
bool inPowerHour = includePowerHour ? not na(time(timeframe.period, nyPowerHour, sessionTimezone)) : false
bool inSession = inLondon or inNY or inPowerHour
bool sessionOK = onlyKeySession ? inSession : true

bool londonStart = na(time(timeframe.period, londonWindow, sessionTimezone)[1]) and inLondon and timeframe.isintraday
bool nyStart = na(time(timeframe.period, nyWindow, sessionTimezone)[1]) and inNY and timeframe.isintraday
bool powerHourStart = includePowerHour and na(time(timeframe.period, nyPowerHour, sessionTimezone)[1]) and inPowerHour and timeframe.isintraday

string currentSession = inNY ? "NY!" : inLondon ? "LDN!" : inPowerHour ? "PWR!" : "---"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  USER DEFINED TYPES  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Imbalance S/R Zone (extends to right)
type ImbSRZone
    float priceTop
    float priceBottom
    bool isBullish
    int startTime
    box zoneBox

// FVG Zone
type DFZone
    float priceTop
    float priceBottom
    bool isBullish
    int startTime
    int state  // 0=fresh, 1=tested, 2=broken

// Single Print
type SPrint
    int startTime
    float highPrice
    float lowPrice
    line highLine
    line lowLine

// Candle Imbalance Marker (anchored to specific candle)
type CandleImb
    int barIdx
    float priceLevel
    bool isBuyImb
    string pattern  // "CONT", "ABS", "REV"
    line marker

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  STORAGE ARRAYS  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var float buyVol = 0.0
var float sellVol = 0.0
var float cvd = 0.0

// Imbalance S/R Zone Storage
var array<ImbSRZone> imbSRZones = array.new<ImbSRZone>()

// FVG Zone Storage
var array<box> fvgBoxes = array.new<box>()
var array<line> fvgLines = array.new<line>()
var array<DFZone> fvgZones = array.new<DFZone>()

// Single Print Storage
var array<SPrint> singlePrints = array.new<SPrint>()

// Candle Imbalance Markers Storage
var array<CandleImb> candleImbMarkers = array.new<CandleImb>()

// Helper: Get future time for zone extensions
getFutureTime() =>
    time + EXTEND_TIME_MS

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  INTRABAR DELTA ANALYSIS & IMBALANCE DETECTION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Arrays to store bin-level imbalance data for this bar
var array<float> binBuyVolArr = array.new_float(16, 0.0)
var array<float> binSellVolArr = array.new_float(16, 0.0)
var array<bool> binBuyImbArr = array.new_bool(16, false)
var array<bool> binSellImbArr = array.new_bool(16, false)

// Variables for stacked imbalance S/R zones
float thisImbTop = na
float thisImbBottom = na
bool thisImbBull = false
bool hasStackedImbalance = false

// Pattern detection variables
var int buyImbCount = 0
var int sellImbCount = 0
var int lowerHalfBuyImb = 0
var int upperHalfSellImb = 0
var int upperHalfBuyImb = 0
var int lowerHalfSellImb = 0

if timeframe.isintraday and candleRange > 0
    [ltfO, ltfC, ltfV, ltfH, ltfL] = request.security_lower_tf(syminfo.tickerid, analysisTimeframe, [open, close, volume, high, low])
    
    if array.size(ltfC) > 0
        float tBuy = 0.0
        float tSell = 0.0
        
        // Reset bin arrays
        float priceStep = candleRange / candleImbBins
        for idx = 0 to candleImbBins - 1
            array.set(binBuyVolArr, idx, 0.0)
            array.set(binSellVolArr, idx, 0.0)
            array.set(binBuyImbArr, idx, false)
            array.set(binSellImbArr, idx, false)
        
        // Process each intrabar candle
        for i = 0 to array.size(ltfC) - 1
            float ltfRange = array.get(ltfH, i) - array.get(ltfL, i)
            float ltfClose = array.get(ltfC, i)
            float ltfOpen = array.get(ltfO, i)
            float ltfVol = array.get(ltfV, i)
            float ltfLow = array.get(ltfL, i)
            float ltfHigh = array.get(ltfH, i)
            
            // Calculate buy/sell split
            float buyPctCalc = 0.5
            if ltfRange > 0
                buyPctCalc := (ltfClose - ltfLow) / ltfRange
            else
                buyPctCalc := ltfClose >= ltfOpen ? 1.0 : 0.0
            
            float barBuy = buyPctCalc * ltfVol
            float barSell = (1 - buyPctCalc) * ltfVol
            
            tBuy += barBuy
            tSell += barSell
            
            // Assign to price bin
            float typicalPrice = (ltfHigh + ltfLow + ltfClose) / 3
            typicalPrice := math.max(low, math.min(high, typicalPrice))
            
            int binIdx = math.floor((typicalPrice - low) / priceStep)
            binIdx := math.max(0, math.min(binIdx, candleImbBins - 1))
            
            array.set(binBuyVolArr, binIdx, array.get(binBuyVolArr, binIdx) + barBuy)
            array.set(binSellVolArr, binIdx, array.get(binSellVolArr, binIdx) + barSell)
        
        buyVol := tBuy
        sellVol := tSell
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DETECT IMBALANCES AT EACH PRICE LEVEL
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        buyImbCount := 0
        sellImbCount := 0
        lowerHalfBuyImb := 0
        upperHalfSellImb := 0
        upperHalfBuyImb := 0
        lowerHalfSellImb := 0
        
        int halfPoint = candleImbBins / 2
        
        for k = 0 to candleImbBins - 1
            float binBuy = array.get(binBuyVolArr, k)
            float binSell = array.get(binSellVolArr, k)
            float totalBinVol = binBuy + binSell
            
            bool hasBinVol = totalBinVol > 0
            
            // Check for buy imbalance (buyers dominated)
            bool isBuyImb = hasBinVol and (binSell > 0 ? (binBuy / binSell >= candleImbRatio) : binBuy > 0)
            // Check for sell imbalance (sellers dominated)
            bool isSellImb = hasBinVol and (binBuy > 0 ? (binSell / binBuy >= candleImbRatio) : binSell > 0)
            
            array.set(binBuyImbArr, k, isBuyImb)
            array.set(binSellImbArr, k, isSellImb)
            
            if isBuyImb
                buyImbCount += 1
                if k < halfPoint
                    lowerHalfBuyImb += 1
                else
                    upperHalfBuyImb += 1
            
            if isSellImb
                sellImbCount += 1
                if k >= halfPoint
                    upperHalfSellImb += 1
                else
                    lowerHalfSellImb += 1
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DETECT STACKED IMBALANCES FOR S/R ZONES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        int bullStackCount = 0
        int bearStackCount = 0
        int bullStackStart = -1
        int bearStackStart = -1
        int bullStackEnd = -1
        int bearStackEnd = -1
        
        for k = 0 to candleImbBins - 1
            bool isBullImb = array.get(binBuyImbArr, k)
            bool isBearImb = array.get(binSellImbArr, k)
            
            // Track bullish stacks
            if isBullImb
                if bullStackCount == 0
                    bullStackStart := k
                bullStackCount += 1
                bullStackEnd := k
            else
                if bullStackCount >= minStackedLevels
                    thisImbTop := low + (bullStackEnd + 1) * priceStep
                    thisImbBottom := low + bullStackStart * priceStep
                    thisImbBull := true
                    hasStackedImbalance := true
                bullStackCount := 0
                bullStackStart := -1
            
            // Track bearish stacks
            if isBearImb
                if bearStackCount == 0
                    bearStackStart := k
                bearStackCount += 1
                bearStackEnd := k
            else
                if bearStackCount >= minStackedLevels and not hasStackedImbalance
                    thisImbTop := low + (bearStackEnd + 1) * priceStep
                    thisImbBottom := low + bearStackStart * priceStep
                    thisImbBull := false
                    hasStackedImbalance := true
                bearStackCount := 0
                bearStackStart := -1
        
        // Check end of loop
        if bullStackCount >= minStackedLevels and not hasStackedImbalance
            thisImbTop := low + (bullStackEnd + 1) * priceStep
            thisImbBottom := low + bullStackStart * priceStep
            thisImbBull := true
            hasStackedImbalance := true
        
        if bearStackCount >= minStackedLevels and not hasStackedImbalance
            thisImbTop := low + (bearStackEnd + 1) * priceStep
            thisImbBottom := low + bearStackStart * priceStep
            thisImbBull := false
            hasStackedImbalance := true

else
    // Fallback for non-intraday
    float rng = high - low
    if rng > 0
        float buyPctEst = (close - low) / rng
        buyVol := buyPctEst * volume
        sellVol := (1 - buyPctEst) * volume
    else
        if close >= open
            buyVol := volume
            sellVol := 0
        else
            sellVol := volume
            buyVol := 0

// Update CVD
float barDelta = buyVol - sellVol
cvd := cvd + barDelta

float totalVol = buyVol + sellVol
float buyPct = totalVol > 0 ? buyVol / totalVol : 0.5
float sellPct = totalVol > 0 ? sellVol / totalVol : 0.5

bool buyDominant = buyPct >= deltaThreshold
bool sellDominant = sellPct >= deltaThreshold
bool strongDelta = buyPct >= 0.70 or sellPct >= 0.70

// CVD trend
float cvdMA = ta.sma(cvd, 5)
bool cvdBullish = cvd > cvdMA
bool cvdBearish = cvd < cvdMA

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  CANDLE-ANCHORED IMBALANCE VISUALIZATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Pattern Detection Logic:
// CONTINUATION: Imbalances align with direction (buy imb in lower half of bull = continuation up)
// ABSORPTION:   Imbalances appear opposite but at extremes (sell imb at top of bull = absorbed sellers)
// REVERSAL:     Strong imbalances in wick areas suggesting exhaustion

bool shouldShowCandleImb = showCandleImb and timeframe.isintraday and candleRange > 0
if imbOnlyTiered
    shouldShowCandleImb := shouldShowCandleImb and isTiered
if imbOnlySession
    shouldShowCandleImb := shouldShowCandleImb and inSession

if shouldShowCandleImb and barstate.isconfirmed and (buyImbCount > 0 or sellImbCount > 0)
    float priceStep = candleRange / candleImbBins
    int halfPoint = candleImbBins / 2
    
    for k = 0 to candleImbBins - 1
        bool isBuyImb = array.get(binBuyImbArr, k)
        bool isSellImb = array.get(binSellImbArr, k)
        
        if isBuyImb or isSellImb
            // Calculate exact price level (center of bin)
            float levelPrice = low + (k + 0.5) * priceStep
            
            // Determine pattern type
            string pattern = "CONT"
            color markerColor = isBuyImb ? buyImbColor : sellImbColor
            
            // Check position relative to candle structure
            bool inLowerWick = levelPrice < bodyLow
            bool inUpperWick = levelPrice > bodyHigh
            bool inBody = levelPrice >= bodyLow and levelPrice <= bodyHigh
            bool inLowerHalf = k < halfPoint
            bool inUpperHalf = k >= halfPoint
            
            if isBuyImb
                if isBullish
                    // Buy imbalance on bull candle
                    if inLowerWick or (inBody and inLowerHalf)
                        // Continuation: Buyers pushing up from bottom
                        pattern := "CONT"
                        markerColor := buyImbColor
                    else if inUpperWick
                        // Absorption: Buyers absorbing at highs (potential reversal)
                        pattern := "ABS"
                        markerColor := absorbColor
                else
                    // Buy imbalance on bear candle
                    if inLowerWick
                        // Absorption: Buyers absorbing at lows (potential bounce)
                        pattern := "ABS"
                        markerColor := absorbColor
                    else if inUpperHalf or inUpperWick
                        // Reversal: Buyers fighting at top of bear candle
                        pattern := "REV"
                        markerColor := reversalColor
            
            if isSellImb
                if isBearish
                    // Sell imbalance on bear candle
                    if inUpperWick or (inBody and inUpperHalf)
                        // Continuation: Sellers pushing down from top
                        pattern := "CONT"
                        markerColor := sellImbColor
                    else if inLowerWick
                        // Absorption: Sellers absorbed at lows (potential bounce)
                        pattern := "ABS"
                        markerColor := absorbColor
                else
                    // Sell imbalance on bull candle
                    if inUpperWick
                        // Absorption: Sellers absorbed at highs
                        pattern := "ABS"
                        markerColor := absorbColor
                    else if inLowerHalf or inLowerWick
                        // Reversal: Sellers fighting at bottom of bull
                        pattern := "REV"
                        markerColor := reversalColor
            
            // Draw marker as small horizontal line ANCHORED to the candle
            // Using bar_index ensures it sticks to the candle on resize
            // NOTE: Must use separate line.new calls because line.style_* are const int
            
            line imbLine = na
            
            if pattern == "CONT"
                // Continuation: solid thick line
                imbLine := line.new(
                     x1=bar_index,
                     y1=levelPrice,
                     x2=bar_index,
                     y2=levelPrice + priceStep * 0.8,
                     color=markerColor,
                     width=3,
                     style=line.style_solid)
            else if pattern == "ABS"
                // Absorption: dashed line
                imbLine := line.new(
                     x1=bar_index,
                     y1=levelPrice,
                     x2=bar_index,
                     y2=levelPrice + priceStep * 0.8,
                     color=markerColor,
                     width=2,
                     style=line.style_dashed)
            else
                // Reversal: dotted line
                imbLine := line.new(
                     x1=bar_index,
                     y1=levelPrice,
                     x2=bar_index,
                     y2=levelPrice + priceStep * 0.8,
                     color=markerColor,
                     width=2,
                     style=line.style_dotted)
            
            // Store for cleanup
            CandleImb newImb = CandleImb.new()
            newImb.barIdx := bar_index
            newImb.priceLevel := levelPrice
            newImb.isBuyImb := isBuyImb
            newImb.pattern := pattern
            newImb.marker := imbLine
            array.push(candleImbMarkers, newImb)

// Cleanup old candle imbalance markers
if array.size(candleImbMarkers) > 0
    int maxMarkerAge = maxZoneAge
    for i = array.size(candleImbMarkers) - 1 to 0
        if i >= array.size(candleImbMarkers)
            continue
        CandleImb imb = array.get(candleImbMarkers, i)
        int age = bar_index - imb.barIdx
        if age > maxMarkerAge
            line.delete(imb.marker)
            array.remove(candleImbMarkers, i)

// Limit total markers
while array.size(candleImbMarkers) > 300
    CandleImb oldImb = array.shift(candleImbMarkers)
    line.delete(oldImb.marker)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  IMBALANCE S/R ZONE VISUALIZATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool imbVolOK = volRatio >= imbVolFilter
bool imbSessionOK = imbOnlySession ? inSession : true

if showImbZones and hasStackedImbalance and imbVolOK and imbSessionOK and barstate.isconfirmed
    if not na(thisImbTop) and not na(thisImbBottom) and thisImbTop > thisImbBottom
        color zoneCol = thisImbBull ? bullImbZoneColor : bearImbZoneColor
        color borderCol = thisImbBull ? color.new(#00E676, 40) : color.new(#FF5252, 40)
        
        // Create zone box using TIME coordinates for right extension
        box imbBox = box.new(
             left=time,
             top=thisImbTop,
             right=getFutureTime(),
             bottom=thisImbBottom,
             xloc=xloc.bar_time,
             bgcolor=zoneCol,
             border_color=borderCol,
             border_width=1)
        
        ImbSRZone newZone = ImbSRZone.new()
        newZone.priceTop := thisImbTop
        newZone.priceBottom := thisImbBottom
        newZone.isBullish := thisImbBull
        newZone.startTime := time
        newZone.zoneBox := imbBox
        array.push(imbSRZones, newZone)

// Manage imbalance S/R zones
if array.size(imbSRZones) > 0
    int barDuration = timeframe.in_seconds() * 1000
    int ageThresholdMs = maxZoneAge * 2 * barDuration
    
    for i = array.size(imbSRZones) - 1 to 0
        if i >= array.size(imbSRZones)
            continue
        ImbSRZone zone = array.get(imbSRZones, i)
        int ageMs = time - zone.startTime
        
        if ageMs > ageThresholdMs
            box.delete(zone.zoneBox)
            array.remove(imbSRZones, i)
            continue
        
        // Check if zone has been filled
        bool zoneFilled = false
        if zone.isBullish and close < zone.priceBottom
            zoneFilled := true
        if not zone.isBullish and close > zone.priceTop
            zoneFilled := true
        
        if zoneFilled
            box.set_bgcolor(zone.zoneBox, color.new(color.gray, 90))
            box.set_border_color(zone.zoneBox, color.new(color.gray, 80))

while array.size(imbSRZones) > maxImbZones
    ImbSRZone oldZone = array.shift(imbSRZones)
    box.delete(oldZone.zoneBox)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  DEEPFLOW FVG ZONE DETECTION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool fvgBullRaw = low > high[2]
bool fvgBearRaw = high < low[2]

float bullGapSize = fvgBullRaw ? (low - high[2]) : 0
float bearGapSize = fvgBearRaw ? (low[2] - high) : 0

bool gapSizeOK_Bull = bullGapSize >= atr * minGapATR
bool gapSizeOK_Bear = bearGapSize >= atr * minGapATR

bool impulseOK_Bull = candleRange[1] > avgRange * zoneImpulseMultiplier and 
                      (math.abs(close[1] - open[1]) / (high[1] - low[1])) >= bodyRatio
bool impulseOK_Bear = candleRange[1] > avgRange * zoneImpulseMultiplier and 
                      (math.abs(close[1] - open[1]) / (high[1] - low[1])) >= bodyRatio

bool zoneVolumeOK = volume[1] >= avgVol * minVolRatio
bool deltaOK_Bull = close[1] > open[1]
bool deltaOK_Bear = close[1] < open[1]

bool validBullFVG = fvgBullRaw and gapSizeOK_Bull and impulseOK_Bull and zoneVolumeOK and deltaOK_Bull and sessionOK
bool validBearFVG = fvgBearRaw and gapSizeOK_Bear and impulseOK_Bear and zoneVolumeOK and deltaOK_Bear and sessionOK

bool isSniperImpulse = (candleRange > avgRange * zoneImpulseMultiplier) and (currentBodyRatio >= bodyRatio) and (volRatio >= minVolRatio)
bool sniperSinglePrint = isSniperImpulse and ((isBullish and buyDominant) or (isBearish and sellDominant)) and sessionOK

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  CREATE FVG ZONES  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if showZones and barstate.isconfirmed
    if validBullFVG
        float topPrice = low
        float bottomPrice = high[2]
        float entry = (topPrice + bottomPrice) / 2
        
        box zoneBox = box.new(
             left=time[2], 
             top=topPrice, 
             right=getFutureTime(), 
             bottom=bottomPrice,
             xloc=xloc.bar_time,
             border_color=color.new(#00E676, 40), 
             bgcolor=bullZoneColor, 
             border_width=2)
        line entryLine = line.new(
             x1=time[2], 
             y1=entry, 
             x2=getFutureTime(), 
             y2=entry,
             xloc=xloc.bar_time,
             color=color.new(#FFFFFF, 40), 
             style=line.style_dotted, 
             width=1)
        
        DFZone newZone = DFZone.new()
        newZone.priceTop := topPrice
        newZone.priceBottom := bottomPrice
        newZone.isBullish := true
        newZone.startTime := time
        newZone.state := 0
        
        array.push(fvgBoxes, zoneBox)
        array.push(fvgLines, entryLine)
        array.push(fvgZones, newZone)
    
    if validBearFVG
        float topPrice = low[2]
        float bottomPrice = high
        float entry = (topPrice + bottomPrice) / 2
        
        box zoneBox = box.new(
             left=time[2], 
             top=topPrice, 
             right=getFutureTime(), 
             bottom=bottomPrice,
             xloc=xloc.bar_time,
             border_color=color.new(#FF5252, 40), 
             bgcolor=bearZoneColor, 
             border_width=2)
        line entryLine = line.new(
             x1=time[2], 
             y1=entry, 
             x2=getFutureTime(), 
             y2=entry,
             xloc=xloc.bar_time,
             color=color.new(#FFFFFF, 40), 
             style=line.style_dotted, 
             width=1)
        
        DFZone newZone = DFZone.new()
        newZone.priceTop := topPrice
        newZone.priceBottom := bottomPrice
        newZone.isBullish := false
        newZone.startTime := time
        newZone.state := 0
        
        array.push(fvgBoxes, zoneBox)
        array.push(fvgLines, entryLine)
        array.push(fvgZones, newZone)

// Single Print Lines
if showSinglePrints and sniperSinglePrint and barstate.isconfirmed
    line highLine = line.new(
         x1=time, 
         y1=high, 
         x2=getFutureTime(), 
         y2=high,
         xloc=xloc.bar_time,
         color=singlePrintColor, 
         style=line.style_solid, 
         width=2)
    line lowLine = line.new(
         x1=time, 
         y1=low, 
         x2=getFutureTime(), 
         y2=low,
         xloc=xloc.bar_time,
         color=singlePrintColor, 
         style=line.style_solid, 
         width=2)
    
    SPrint newSP = SPrint.new()
    newSP.startTime := time
    newSP.highPrice := high
    newSP.lowPrice := low
    newSP.highLine := highLine
    newSP.lowLine := lowLine
    array.push(singlePrints, newSP)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  FVG ZONE STATE MANAGEMENT  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var bool atBullZone = false
var bool atBearZone = false
var int activeBullZones = 0
var int activeBearZones = 0

atBullZone := false
atBearZone := false
activeBullZones := 0
activeBearZones := 0

if array.size(fvgZones) > 0
    int barDuration = timeframe.in_seconds() * 1000
    int ageThresholdMs = maxZoneAge * barDuration
    
    for i = array.size(fvgZones) - 1 to 0
        if i >= array.size(fvgZones)
            continue
            
        DFZone zone = array.get(fvgZones, i)
        int ageMs = time - zone.startTime
        
        if ageMs > ageThresholdMs or zone.state >= 2
            if i < array.size(fvgBoxes)
                box.delete(array.get(fvgBoxes, i))
                array.remove(fvgBoxes, i)
            if i < array.size(fvgLines)
                line.delete(array.get(fvgLines, i))
                array.remove(fvgLines, i)
            array.remove(fvgZones, i)
            continue
        
        if zone.state < 2
            if zone.isBullish
                activeBullZones += 1
                if close >= zone.priceBottom and close <= zone.priceTop
                    atBullZone := true
            else
                activeBearZones += 1
                if close >= zone.priceBottom and close <= zone.priceTop
                    atBearZone := true
        
        if zone.isBullish
            if zone.state == 0 and low <= (zone.priceTop + zone.priceBottom) / 2
                zone.state := 1
                if i < array.size(fvgBoxes)
                    box.set_bgcolor(array.get(fvgBoxes, i), color.new(#78909C, 80))
            if zone.state < 2 and close < zone.priceBottom
                zone.state := 2
                if i < array.size(fvgBoxes)
                    box.set_bgcolor(array.get(fvgBoxes, i), color.new(color.gray, 90))
        else
            if zone.state == 0 and high >= (zone.priceTop + zone.priceBottom) / 2
                zone.state := 1
                if i < array.size(fvgBoxes)
                    box.set_bgcolor(array.get(fvgBoxes, i), color.new(#78909C, 80))
            if zone.state < 2 and close > zone.priceTop
                zone.state := 2
                if i < array.size(fvgBoxes)
                    box.set_bgcolor(array.get(fvgBoxes, i), color.new(color.gray, 90))

// Garbage collection
while array.size(fvgZones) > maxZones
    if array.size(fvgBoxes) > 0
        box.delete(array.get(fvgBoxes, 0))
        array.remove(fvgBoxes, 0)
    if array.size(fvgLines) > 0
        line.delete(array.get(fvgLines, 0))
        array.remove(fvgLines, 0)
    if array.size(fvgZones) > 0
        array.remove(fvgZones, 0)

// Single print cleanup
if array.size(singlePrints) > 0
    int barDuration = timeframe.in_seconds() * 1000
    int ageThresholdMs = maxZoneAge * barDuration
    
    for i = array.size(singlePrints) - 1 to 0
        if i >= array.size(singlePrints)
            continue
        SPrint sp = array.get(singlePrints, i)
        int ageMs = time - sp.startTime
        if ageMs > ageThresholdMs
            line.delete(sp.highLine)
            line.delete(sp.lowLine)
            array.remove(singlePrints, i)

while array.size(singlePrints) > maxZones
    SPrint oldSP = array.shift(singlePrints)
    line.delete(oldSP.highLine)
    line.delete(oldSP.lowLine)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  IMBALANCE SUPPORT CHECKS  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Check for supporting imbalance zone
bool hasImbSupport = false
if array.size(imbSRZones) > 0
    int barDuration = timeframe.in_seconds() * 1000
    int recentThresholdMs = 20 * barDuration
    
    for i = 0 to math.min(array.size(imbSRZones) - 1, 10)
        ImbSRZone zone = array.get(imbSRZones, i)
        if time - zone.startTime <= recentThresholdMs
            if zone.isBullish and close >= zone.priceBottom and close <= zone.priceTop + atr * 0.5
                hasImbSupport := true
            if not zone.isBullish and close >= zone.priceBottom - atr * 0.5 and close <= zone.priceTop
                hasImbSupport := true

// Candle imbalance alignment scoring
bool imbAlignedLong = isBullish and lowerHalfBuyImb >= 2
bool imbAlignedShort = isBearish and upperHalfSellImb >= 2

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  CONFLUENCE SCORING & SIGNAL GENERATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool confirmedLong = isBullish and buyDominant
bool confirmedShort = isBearish and sellDominant

bool cvdConfirmLong = not requireCVDConfirm or cvdBullish
bool cvdConfirmShort = not requireCVDConfirm or cvdBearish

// Base signal requirements
bool baseLong = isTiered and hasVolume and confirmedLong and hasStrongBody and hasSignificantRange and wicksOK and cvdConfirmLong and sessionOK
bool baseShort = isTiered and hasVolume and confirmedShort and hasStrongBody and hasSignificantRange and wicksOK and cvdConfirmShort and sessionOK

// Calculate confluence scores
int longConfluence = 0
int shortConfluence = 0

if baseLong
    longConfluence := tierScore
    longConfluence += atBullZone ? 2 : 0
    longConfluence += imbAlignedLong ? 1 : 0      // NEW: Candle imbalance alignment
    longConfluence += hasImbSupport ? 1 : 0
    longConfluence += hasStrongVolume ? 1 : 0
    longConfluence += strongDelta and buyPct >= 0.70 ? 1 : 0
    longConfluence += cvdBullish ? 1 : 0

if baseShort
    shortConfluence := tierScore
    shortConfluence += atBearZone ? 2 : 0
    shortConfluence += imbAlignedShort ? 1 : 0   // NEW: Candle imbalance alignment
    shortConfluence += hasImbSupport ? 1 : 0
    shortConfluence += hasStrongVolume ? 1 : 0
    shortConfluence += strongDelta and sellPct >= 0.70 ? 1 : 0
    shortConfluence += cvdBearish ? 1 : 0

// Final signals
bool longSignal = baseLong and longConfluence >= minConfluenceScore
bool shortSignal = baseShort and shortConfluence >= minConfluenceScore

bool sLong = longSignal and isTierS
bool aLong = longSignal and isTierA
bool bLong = longSignal and isTierB

bool sShort = shortSignal and isTierS
bool aShort = shortSignal and isTierA
bool bShort = shortSignal and isTierB

// Zone entry signals
bool dfzBuyEntry = atBullZone and buyDominant and volRatio >= 1.5 and sessionOK
bool dfzSellEntry = atBearZone and sellDominant and volRatio >= 1.5 and sessionOK

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  STOP LOSS CALCULATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float longStop = na
float shortStop = na
float longTarget = na
float shortTarget = na

if longSignal
    longStop := low - TICK_VALUE * 2
    float riskPts = close - longStop
    float rewardMult = isTierS ? 2.5 : isTierA ? 2.0 : 1.5
    longTarget := close + (riskPts * rewardMult)

if shortSignal
    shortStop := high + TICK_VALUE * 2
    float riskPts = shortStop - close
    float rewardMult = isTierS ? 2.5 : isTierA ? 2.0 : 1.5
    shortTarget := close - (riskPts * rewardMult)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  VISUALIZATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// GRA Tier Signals
plotshape(sLong, "S Long", shape.triangleup, location.belowbar, sTierColor, size=size.normal, text="SğŸ¯", textcolor=color.white)
plotshape(aLong, "A Long", shape.triangleup, location.belowbar, aTierColor, size=size.small, text="AğŸ¯", textcolor=color.white)
plotshape(bLong, "B Long", shape.triangleup, location.belowbar, bTierColor, size=size.tiny, text="BğŸ¯", textcolor=color.white)

plotshape(sShort, "S Short", shape.triangledown, location.abovebar, sTierColor, size=size.normal, text="SğŸ¯", textcolor=color.white)
plotshape(aShort, "A Short", shape.triangledown, location.abovebar, aTierColor, size=size.small, text="AğŸ¯", textcolor=color.white)
plotshape(bShort, "B Short", shape.triangledown, location.abovebar, bTierColor, size=size.tiny, text="BğŸ¯", textcolor=color.white)

// Zone Entry Signals
bool showDFZBuy = dfzBuyEntry and not longSignal
bool showDFZSell = dfzSellEntry and not shortSignal
plotshape(showDFZBuy, "DFZ Buy", shape.labelup, location.belowbar, color.new(#00E676, 0), text="ZğŸ¯", textcolor=color.white, size=size.tiny)
plotshape(showDFZSell, "DFZ Sell", shape.labeldown, location.abovebar, color.new(#FF5252, 0), text="ZğŸ¯", textcolor=color.white, size=size.tiny)

// Single Print markers
plotshape(sniperSinglePrint and isBullish, "SP Bull", shape.diamond, location.belowbar, singlePrintColor, size=size.tiny, text="SP", textcolor=color.white)
plotshape(sniperSinglePrint and isBearish, "SP Bear", shape.diamond, location.abovebar, singlePrintColor, size=size.tiny, text="SP", textcolor=color.white)

// Session Markers
plotshape(londonStart, "LDN", shape.diamond, location.abovebar, color.new(#2196F3, 0), size=size.tiny, text="LDN", textcolor=color.white)
plotshape(nyStart, "NY", shape.diamond, location.abovebar, color.new(#4CAF50, 0), size=size.tiny, text="NY", textcolor=color.white)
plotshape(powerHourStart, "PWR", shape.diamond, location.abovebar, color.new(#FF9800, 0), size=size.tiny, text="PWR", textcolor=color.white)

// Session backgrounds
bgcolor(inLondon ? color.new(#2196F3, 96) : na, title="London BG")
bgcolor(inNY ? color.new(#4CAF50, 96) : na, title="NY BG")
bgcolor(inPowerHour ? color.new(#FF9800, 96) : na, title="Power Hour BG")

// Stop/Target lines
plot(longSignal ? longStop : na, "Long Stop", color.new(#FF5252, 0), 2, plot.style_linebr)
plot(longSignal ? longTarget : na, "Long Target", color.new(#00E676, 0), 2, plot.style_linebr)
plot(shortSignal ? shortStop : na, "Short Stop", color.new(#FF5252, 0), 2, plot.style_linebr)
plot(shortSignal ? shortTarget : na, "Short Target", color.new(#00E676, 0), 2, plot.style_linebr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  INFO TABLE  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var table panel = table.new(position.top_right, 2, 14, bgcolor=color.new(color.black, 10), border_width=1, border_color=color.new(#333333, 0))

color tierCol = isTierS ? sTierColor : isTierA ? aTierColor : isTierB ? bTierColor : color.white

table.cell(panel, 0, 0, "YM", text_color=color.white, text_size=size.small, bgcolor=color.new(#2196F3, 30))
table.cell(panel, 1, 0, "ğŸ¯v4", text_color=color.white, text_size=size.small, bgcolor=color.new(#2196F3, 30))

table.cell(panel, 0, 1, "Pts", text_color=color.white, text_size=size.tiny)
table.cell(panel, 1, 1, str.tostring(candlePoints, "#.#"), text_color=tierCol, text_size=size.tiny)

table.cell(panel, 0, 2, "Tier", text_color=color.white, text_size=size.tiny)
table.cell(panel, 1, 2, tier, text_color=tierCol, text_size=size.tiny)

color vCol = hasStrongVolume ? color.lime : hasVolume ? color.green : color.red
table.cell(panel, 0, 3, "Vol", text_color=color.white, text_size=size.tiny)
table.cell(panel, 1, 3, str.tostring(volRatio, "#.#") + "x", text_color=vCol, text_size=size.tiny)

string dStr = buyPct > sellPct ? str.tostring(buyPct * 100, "#") + "%B" : str.tostring(sellPct * 100, "#") + "%S"
color dCol = buyDominant ? color.new(#00E676, 0) : sellDominant ? color.new(#FF5252, 0) : color.white
table.cell(panel, 0, 4, "Delta", text_color=color.white, text_size=size.tiny)
table.cell(panel, 1, 4, dStr, text_color=dCol, text_size=size.tiny)

color bCol = hasStrongBody ? color.green : color.red
table.cell(panel, 0, 5, "Body", text_color=color.white, text_size=size.tiny)
table.cell(panel, 1, 5, str.tostring(currentBodyRatio * 100, "#") + "%", text_color=bCol, text_size=size.tiny)

string cvdDir = cvdBullish ? "â–²" : "â–¼"
color cvdCol = cvdBullish ? color.new(#00E676, 0) : color.new(#FF5252, 0)
table.cell(panel, 0, 6, "CVD", text_color=color.white, text_size=size.tiny)
table.cell(panel, 1, 6, cvdDir, text_color=cvdCol, text_size=size.tiny)

color sCol = inSession ? color.yellow : color.gray
table.cell(panel, 0, 7, "Sess", text_color=color.white, text_size=size.tiny)
table.cell(panel, 1, 7, currentSession, text_color=sCol, text_size=size.tiny)

// NEW: Imbalance info instead of POC
string imbInfo = str.tostring(buyImbCount) + "B/" + str.tostring(sellImbCount) + "S"
color imbCol = buyImbCount > sellImbCount ? buyImbColor : sellImbCount > buyImbCount ? sellImbColor : color.white
table.cell(panel, 0, 8, "IMB", text_color=color.white, text_size=size.tiny)
table.cell(panel, 1, 8, imbInfo, text_color=imbCol, text_size=size.tiny)

string zoneStatus = atBullZone ? "BUYâ¬š" : atBearZone ? "SELLâ¬š" : "---"
color zoneCol = atBullZone ? color.new(#00E676, 0) : atBearZone ? color.new(#FF5252, 0) : color.white
table.cell(panel, 0, 9, "FVG", text_color=color.white, text_size=size.tiny)
table.cell(panel, 1, 9, zoneStatus, text_color=zoneCol, text_size=size.tiny)

table.cell(panel, 0, 10, "Zones", text_color=color.white, text_size=size.tiny)
table.cell(panel, 1, 10, str.tostring(activeBullZones) + "B/" + str.tostring(activeBearZones) + "S", text_color=color.white, text_size=size.tiny)

int activeScore = longSignal ? longConfluence : shortSignal ? shortConfluence : math.max(baseLong ? longConfluence : 0, baseShort ? shortConfluence : 0)
color scoreCol = activeScore >= 7 ? color.lime : activeScore >= 5 ? color.yellow : color.gray
table.cell(panel, 0, 11, "Score", text_color=color.white, text_size=size.tiny)
table.cell(panel, 1, 11, str.tostring(activeScore) + "/10", text_color=scoreCol, text_size=size.tiny)

table.cell(panel, 0, 12, "S/R", text_color=color.white, text_size=size.tiny)
table.cell(panel, 1, 12, str.tostring(array.size(imbSRZones)), text_color=array.size(imbSRZones) > 0 ? color.yellow : color.gray, text_size=size.tiny)

string rrStr = "---"
if longSignal and not na(longStop) and not na(longTarget)
    float risk = close - longStop
    float reward = longTarget - close
    rrStr := "1:" + str.tostring(reward/risk, "#.#")
else if shortSignal and not na(shortStop) and not na(shortTarget)
    float risk = shortStop - close
    float reward = close - shortTarget
    rrStr := "1:" + str.tostring(reward/risk, "#.#")
table.cell(panel, 0, 13, "R:R", text_color=color.white, text_size=size.tiny)
table.cell(panel, 1, 13, rrStr, text_color=(longSignal or shortSignal) ? color.lime : color.gray, text_size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  ALERTS  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

alertcondition(sLong, title="ğŸ¯ YM S-TIER LONG", message="ğŸ¯ğŸ¥‡ YM SNIPER S-TIER LONG {{ticker}} @ {{close}} | HOLD")
alertcondition(aLong, title="ğŸ¯ YM A-TIER LONG", message="ğŸ¯ğŸ¥ˆ YM SNIPER A-TIER LONG {{ticker}} @ {{close}} | SWING")
alertcondition(bLong, title="ğŸ¯ YM B-TIER LONG", message="ğŸ¯ğŸ¥‰ YM SNIPER B-TIER LONG {{ticker}} @ {{close}} | SCALP")

alertcondition(sShort, title="ğŸ¯ YM S-TIER SHORT", message="ğŸ¯ğŸ¥‡ YM SNIPER S-TIER SHORT {{ticker}} @ {{close}} | HOLD")
alertcondition(aShort, title="ğŸ¯ YM A-TIER SHORT", message="ğŸ¯ğŸ¥ˆ YM SNIPER A-TIER SHORT {{ticker}} @ {{close}} | SWING")
alertcondition(bShort, title="ğŸ¯ YM B-TIER SHORT", message="ğŸ¯ğŸ¥‰ YM SNIPER B-TIER SHORT {{ticker}} @ {{close}} | SCALP")

alertcondition(dfzBuyEntry, title="ğŸ¯ YM ZONE BUY", message="ğŸŸ¢ YM ZONE BUY ENTRY {{ticker}} @ {{close}}")
alertcondition(dfzSellEntry, title="ğŸ¯ YM ZONE SELL", message="ğŸ”´ YM ZONE SELL ENTRY {{ticker}} @ {{close}}")

alertcondition(validBullFVG, title="ğŸ“¦ NEW BULL FVG", message="ğŸŸ© NEW YM BULLISH FVG ZONE {{ticker}}")
alertcondition(validBearFVG, title="ğŸ“¦ NEW BEAR FVG", message="ğŸŸ¥ NEW YM BEARISH FVG ZONE {{ticker}}")

alertcondition(sniperSinglePrint, title="â­ SINGLE PRINT", message="â­ YM SINGLE PRINT {{ticker}} @ {{close}}")

alertcondition(londonStart, title="LONDON OPEN", message="London Open - YM Active")
alertcondition(nyStart, title="NY OPEN", message="NY Open - YM Active")
alertcondition(powerHourStart, title="POWER HOUR", message="Power Hour - YM Active")

// Master Alert
if longSignal or shortSignal
    string t = tier
    string d = longSignal ? "LONG" : "SHORT"
    string act = isTierS ? "HOLD" : isTierA ? "SWING" : "SCALP"
    string deltaInfo = longSignal ? str.tostring(buyPct * 100, "#") + "%B" : str.tostring(sellPct * 100, "#") + "%S"
    string scoreInfo = " | Score: " + str.tostring(longSignal ? longConfluence : shortConfluence) + "/10"
    string zoneInfo = atBullZone or atBearZone ? " | IN ZONE" : ""
    string imbInfo2 = " | IMB: " + str.tostring(buyImbCount) + "B/" + str.tostring(sellImbCount) + "S"
    string stopInfo = longSignal and not na(longStop) ? " | Stop: " + str.tostring(longStop, format.mintick) : shortSignal and not na(shortStop) ? " | Stop: " + str.tostring(shortStop, format.mintick) : ""
    alert("ğŸ¯ YM " + t + "-" + d + " | " + syminfo.ticker + " @ " + str.tostring(close, format.mintick) + " | " + deltaInfo + scoreInfo + zoneInfo + imbInfo2 + stopInfo + " | " + act, alert.freq_once_per_bar_close)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  END OF INDICATOR  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
