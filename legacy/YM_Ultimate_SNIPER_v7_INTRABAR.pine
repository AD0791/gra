// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0
// Â© Alexandro Disla - YM Ultimate SNIPER v7
// INTRABAR EDITION | Order Blocks + Liquidity Sweeps + IFVG + INTRABAR ANALYSIS
// TARGET: 3-7 High-Confluence Trades per Day
// "Zones That Matter" + "See Inside The Candle" Philosophy

//@version=6
indicator("YM Ultimate SNIPER v7", shorttitle="YMğŸ¯v7", overlay=true, 
     max_labels_count=500, max_boxes_count=500, max_lines_count=500)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  CONSTANTS & INSTRUMENT  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var float TICK_VALUE = syminfo.mintick
var int EXTEND_BARS = 500

// Auto-detect instrument for proper tier thresholds
var string INSTRUMENT = syminfo.ticker
var bool IS_YM = str.contains(INSTRUMENT, "YM") or str.contains(INSTRUMENT, "MYM")
var bool IS_NQ = str.contains(INSTRUMENT, "NQ") or str.contains(INSTRUMENT, "MNQ")
var bool IS_ES = str.contains(INSTRUMENT, "ES") or str.contains(INSTRUMENT, "MES")
var bool IS_GC = str.contains(INSTRUMENT, "GC") or str.contains(INSTRUMENT, "MGC")
var bool IS_BTC = str.contains(INSTRUMENT, "BTC")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  CONFIGURATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string GRP_TIER = "â•â•â•â•â•â•â•â•â•â•â• TIER THRESHOLDS â•â•â•â•â•â•â•â•â•â•â•"
float sTierPoints = input.float(50.0, "S-Tier (Points)", minval=20, maxval=200, step=5, group=GRP_TIER,
     tooltip="S-Tier: HOLD position (institutional sweep)")
float aTierPoints = input.float(25.0, "A-Tier (Points)", minval=10, maxval=100, step=5, group=GRP_TIER,
     tooltip="A-Tier: SWING trade (strong momentum)")
float bTierPoints = input.float(12.0, "B-Tier (Points)", minval=5, maxval=50, step=1, group=GRP_TIER,
     tooltip="B-Tier: SCALP quick (quick grab)")

string GRP_SNIPER = "â•â•â•â•â•â•â•â•â•â•â• SNIPER FILTERS â•â•â•â•â•â•â•â•â•â•â•"
float minVolRatio = input.float(1.8, "Min Volume Ratio", minval=1.0, maxval=3.0, step=0.1, group=GRP_SNIPER)
float deltaThreshold = input.float(0.62, "Delta Dominance %", minval=0.55, maxval=0.80, step=0.01, group=GRP_SNIPER)
float bodyRatio = input.float(0.70, "Min Body Ratio", minval=0.5, maxval=0.9, step=0.02, group=GRP_SNIPER)
float rangeMultiplier = input.float(1.3, "Min Range vs Avg", minval=1.0, maxval=2.5, step=0.1, group=GRP_SNIPER)
bool requireCVDConfirm = input.bool(true, "Require CVD Confirmation", group=GRP_SNIPER)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  INTRABAR ANALYSIS  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string GRP_INTRABAR = "â•â•â•â•â•â•â•â•â•â•â• INTRABAR ANALYSIS â•â•â•â•â•â•â•â•â•â•â•"
bool enableIntrabar = input.bool(true, "Enable Intrabar Analysis", group=GRP_INTRABAR,
     tooltip="Analyze lower timeframe data within each bar for superior delta and momentum detection")
string intrabarTF = input.string("1", "Intrabar Timeframe", 
     options=["1", "5", "15", "30", "60"], group=GRP_INTRABAR,
     tooltip="Lower timeframe to analyze (1=1min is most precise, use higher if too slow)")
float absorptionThreshold = input.float(0.65, "Absorption Detection %", minval=0.50, maxval=0.85, step=0.05, group=GRP_INTRABAR,
     tooltip="Volume clustering threshold for absorption detection")
float intrabarMomentumMin = input.float(0.60, "Min Intrabar Momentum", minval=0.50, maxval=0.80, step=0.05, group=GRP_INTRABAR,
     tooltip="Minimum percentage of intrabar candles in same direction")
bool showIntrabarMetrics = input.bool(true, "Show Intrabar Metrics in Table", group=GRP_INTRABAR)
float intrabarDeltaWeight = input.float(1.5, "Intrabar Delta Confluence Weight", minval=0.5, maxval=3.0, step=0.25, group=GRP_INTRABAR,
     tooltip="How much intrabar delta adds to confluence score (max contribution)")
float absorptionWeight = input.float(1.0, "Absorption Confluence Weight", minval=0.5, maxval=2.0, step=0.25, group=GRP_INTRABAR,
     tooltip="How much absorption detection adds to confluence score")

string GRP_SESSION = "â•â•â•â•â•â•â•â•â•â•â• SESSION WINDOWS â•â•â•â•â•â•â•â•â•â•â•"
bool onlyKeySession = input.bool(true, "Only Signal in Key Sessions", group=GRP_SESSION)
string sessionTimezone = input.string("America/New_York", "Timezone", 
     options=["America/New_York", "America/Chicago", "Europe/London", "UTC"], group=GRP_SESSION)
string londonWindow = input.string("0300-0500", "London Window", group=GRP_SESSION)
string nyWindow = input.string("0930-1130", "NY Open Window", group=GRP_SESSION)
string nyPowerHour = input.string("1500-1600", "NY Power Hour", group=GRP_SESSION)
bool includePowerHour = input.bool(true, "Include Power Hour", group=GRP_SESSION)

string GRP_OB = "â•â•â•â•â•â•â•â•â•â•â• ORDER BLOCKS â•â•â•â•â•â•â•â•â•â•â•"
bool showOrderBlocks = input.bool(true, "Show Order Blocks", group=GRP_OB)
int obLookback = input.int(20, "OB Lookback Bars", minval=10, maxval=50, group=GRP_OB)
float obMinStrength = input.float(1.5, "OB Min Move Strength (ATR)", minval=1.0, maxval=3.0, step=0.1, group=GRP_OB,
     tooltip="Minimum move after OB candle in ATR multiples")
int maxOrderBlocks = input.int(8, "Max Active Order Blocks", minval=3, maxval=15, group=GRP_OB)

string GRP_LIQ = "â•â•â•â•â•â•â•â•â•â•â• LIQUIDITY SWEEPS â•â•â•â•â•â•â•â•â•â•â•"
bool showLiqSweeps = input.bool(true, "Show Liquidity Sweeps", group=GRP_LIQ)
int swingLookback = input.int(15, "Swing Lookback", minval=5, maxval=50, group=GRP_LIQ)
float sweepMinWick = input.float(0.3, "Min Sweep Wick Ratio", minval=0.15, maxval=0.6, step=0.05, group=GRP_LIQ,
     tooltip="Minimum wick size showing rejection")
int maxSweepAge = input.int(3, "Max Sweep Signal Age (bars)", minval=1, maxval=10, group=GRP_LIQ)

string GRP_ZONES = "â•â•â•â•â•â•â•â•â•â•â• FVG & IFVG ZONES â•â•â•â•â•â•â•â•â•â•â•"
bool showFVG = input.bool(true, "Show FVG Zones", group=GRP_ZONES)
bool showIFVG = input.bool(true, "Show IFVG (Inverse FVG)", group=GRP_ZONES)
float minGapATR = input.float(0.25, "Min Gap Size (ATR%)", minval=0.1, maxval=0.8, step=0.05, group=GRP_ZONES)
int maxZoneAge = input.int(75, "Max Zone Age (bars)", minval=30, maxval=200, group=GRP_ZONES)
int maxZones = input.int(10, "Max Active Zones", minval=5, maxval=20, group=GRP_ZONES)
float zoneQualityMin = input.float(6.0, "Min Zone Quality Score", minval=3.0, maxval=9.0, step=0.5, group=GRP_ZONES,
     tooltip="Only show zones that score above this threshold (max 10)")

string GRP_CONFLUENCE = "â•â•â•â•â•â•â•â•â•â•â• CONFLUENCE SCORING â•â•â•â•â•â•â•â•â•â•â•"
float minScoreWeak = input.float(4.5, "Min Score: Medium", minval=2.0, maxval=6.0, step=0.5, group=GRP_CONFLUENCE,
     tooltip="Score below this = WEAK (no signal)")
float minScoreExcellent = input.float(7.0, "Min Score: Excellent", minval=5.0, maxval=9.0, step=0.5, group=GRP_CONFLUENCE,
     tooltip="Score at or above this = EXCELLENT")

string GRP_COLORS = "â•â•â•â•â•â•â•â•â•â•â• COLORS â•â•â•â•â•â•â•â•â•â•â•"
color sTierColor = input.color(color.new(#FFD700, 0), "S-Tier (Gold)", group=GRP_COLORS)
color aTierColor = input.color(color.new(#00E676, 0), "A-Tier (Green)", group=GRP_COLORS)
color bTierColor = input.color(color.new(#FFC107, 0), "B-Tier (Amber)", group=GRP_COLORS)
color bullFVGColor = input.color(color.new(#00E676, 80), "Bullish FVG", group=GRP_COLORS)
color bearFVGColor = input.color(color.new(#FF5252, 80), "Bearish FVG", group=GRP_COLORS)
color bullOBColor = input.color(color.new(#2196F3, 75), "Bullish OB", group=GRP_COLORS)
color bearOBColor = input.color(color.new(#E91E63, 75), "Bearish OB", group=GRP_COLORS)
color ifvgColor = input.color(color.new(#9C27B0, 70), "IFVG", group=GRP_COLORS)
color sweepBullColor = input.color(color.new(#00BCD4, 0), "Bullish Sweep", group=GRP_COLORS)
color sweepBearColor = input.color(color.new(#FF9800, 0), "Bearish Sweep", group=GRP_COLORS)
color intrabarBullColor = input.color(color.new(#00FF7F, 0), "Intrabar Bull", group=GRP_COLORS)
color intrabarBearColor = input.color(color.new(#FF6B6B, 0), "Intrabar Bear", group=GRP_COLORS)

string GRP_TABLE = "â•â•â•â•â•â•â•â•â•â•â• TABLE DISPLAY â•â•â•â•â•â•â•â•â•â•â•"
string tableSize = input.string("normal", "Table Size", options=["tiny", "small", "normal", "large"], group=GRP_TABLE)
string tablePos = input.string("Top Right", "Table Position", 
     options=["Top Right", "Top Left", "Bottom Right", "Bottom Left", "Top Center", "Bottom Center"], group=GRP_TABLE)
int tableTransparency = input.int(5, "Table Background Transparency", minval=0, maxval=50, group=GRP_TABLE)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  CANDLE STRUCTURE  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float bodyHigh = math.max(open, close)
float bodyLow = math.min(open, close)
float bodySize = bodyHigh - bodyLow
float candleRange = high - low
float upperWick = high - bodyHigh
float lowerWick = bodyLow - low

// Points calculation
float candlePoints = candleRange / syminfo.mintick
if IS_NQ
    candlePoints := candleRange / 0.25  // NQ: 4 ticks per point
else if IS_YM
    candlePoints := candleRange / 1.0   // YM: 1 tick per point
else if IS_ES
    candlePoints := candleRange / 0.25  // ES: 4 ticks per point
else if IS_GC
    candlePoints := candleRange / 0.10  // GC: 10 ticks per point
else if IS_BTC
    candlePoints := candleRange / 5.0   // BTC: 5 ticks per point

bool isBullish = close > open
bool isBearish = close < open

float avgRange = ta.sma(candleRange, 20)
float avgVol = ta.sma(volume, 20)
float volRatio = avgVol > 0 ? volume / avgVol : 1.0
float atr = ta.atr(14)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  QUALITY FILTERS  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float currentBodyRatio = candleRange > 0 ? bodySize / candleRange : 0
bool hasStrongBody = currentBodyRatio >= bodyRatio
bool hasSignificantRange = candleRange >= avgRange * rangeMultiplier
bool hasVolume = volRatio >= minVolRatio
bool hasStrongVolume = volRatio >= 2.0
bool hasExtremeVolume = volRatio >= 2.5

// Wick analysis for rejection detection
float upperWickRatio = candleRange > 0 ? upperWick / candleRange : 0
float lowerWickRatio = candleRange > 0 ? lowerWick / candleRange : 0
bool hasUpperRejection = upperWickRatio >= sweepMinWick
bool hasLowerRejection = lowerWickRatio >= sweepMinWick

bool bullWickOK = isBullish ? (upperWick < bodySize * 0.5) : true
bool bearWickOK = isBearish ? (lowerWick < bodySize * 0.5) : true
bool wicksOK = bullWickOK and bearWickOK

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  TIER CLASSIFICATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string tier = candlePoints >= sTierPoints ? "S" : candlePoints >= aTierPoints ? "A" : candlePoints >= bTierPoints ? "B" : "X"
bool isTiered = tier != "X"
bool isTierS = tier == "S"
bool isTierA = tier == "A"
bool isTierB = tier == "B"

float tierScore = isTierS ? 3.0 : isTierA ? 2.0 : isTierB ? 1.0 : 0.0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  SESSION DETECTION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool inLondon = not na(time(timeframe.period, londonWindow, sessionTimezone))
bool inNY = not na(time(timeframe.period, nyWindow, sessionTimezone))
bool inPowerHour = includePowerHour ? not na(time(timeframe.period, nyPowerHour, sessionTimezone)) : false
bool inSession = inLondon or inNY or inPowerHour
bool sessionOK = onlyKeySession ? inSession : true

bool londonStart = na(time(timeframe.period, londonWindow, sessionTimezone)[1]) and inLondon and timeframe.isintraday
bool nyStart = na(time(timeframe.period, nyWindow, sessionTimezone)[1]) and inNY and timeframe.isintraday
bool powerHourStart = includePowerHour and na(time(timeframe.period, nyPowerHour, sessionTimezone)[1]) and inPowerHour and timeframe.isintraday

string currentSession = inNY ? "NY" : inLondon ? "LDN" : inPowerHour ? "PWR" : "OFF"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  INTRABAR ANALYSIS ENGINE  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Intrabar data arrays - request lower timeframe data within current bar
// This gives us the "inside" view of each candle

// Get lower TF OHLCV data
[ibOpen, ibHigh, ibLow, ibClose, ibVol] = request.security_lower_tf(syminfo.tickerid, intrabarTF, 
     [open, high, low, close, volume])

// â•â•â• INTRABAR METRICS CALCULATION â•â•â•

// Intrabar Delta - REAL buy/sell pressure from lower timeframe
var float intrabarBuyVol = 0.0
var float intrabarSellVol = 0.0
var float intrabarDelta = 0.0
var float intrabarDeltaPct = 0.5
var bool intrabarBullDominant = false
var bool intrabarBearDominant = false
var bool intrabarStrongDelta = false
var bool intrabarExtremeDelta = false

// Intrabar Momentum - direction consistency within bar
var int intrabarBullCount = 0
var int intrabarBearCount = 0
var int intrabarTotalBars = 0
var float intrabarMomentum = 0.0
var bool intrabarMomentumBull = false
var bool intrabarMomentumBear = false
var bool intrabarMomentumStrong = false

// Absorption Detection - high volume with little price movement (institutions accumulating)
var bool intrabarAbsorption = false
var float intrabarAbsorptionScore = 0.0
var bool intrabarBullAbsorption = false
var bool intrabarBearAbsorption = false

// Intrabar Internal Sweep - sweep within the bar (hidden liquidity grab)
var bool intrabarInternalSweep = false
var bool intrabarBullInternalSweep = false
var bool intrabarBearInternalSweep = false

// Volume Distribution - where volume clustered (top, middle, bottom of bar)
var float intrabarVolTop = 0.0
var float intrabarVolMid = 0.0
var float intrabarVolBottom = 0.0
var string intrabarVolCluster = "â€”"

// Process intrabar data
if enableIntrabar and barstate.isconfirmed
    // Reset counters
    intrabarBuyVol := 0.0
    intrabarSellVol := 0.0
    intrabarBullCount := 0
    intrabarBearCount := 0
    intrabarVolTop := 0.0
    intrabarVolMid := 0.0
    intrabarVolBottom := 0.0
    
    float barRangeThird = candleRange / 3
    float topZone = high - barRangeThird
    float bottomZone = low + barRangeThird
    
    // Track for internal sweep detection
    float firstHigh = na
    float firstLow = na
    float lastHigh = na
    float lastLow = na
    bool sweptInternalHigh = false
    bool sweptInternalLow = false
    
    int arrSize = array.size(ibClose)
    intrabarTotalBars := arrSize
    
    if arrSize > 0
        for i = 0 to arrSize - 1
            float ibO = array.get(ibOpen, i)
            float ibH = array.get(ibHigh, i)
            float ibL = array.get(ibLow, i)
            float ibC = array.get(ibClose, i)
            float ibV = array.get(ibVol, i)
            
            // â•â•â• INTRABAR DELTA (TRUE BUY/SELL) â•â•â•
            // More accurate than estimation - uses actual candle direction
            bool ibBullish = ibC > ibO
            bool ibBearish = ibC < ibO
            
            // Calculate volume distribution within intrabar candle
            float ibRange = ibH - ibL
            float ibClosePos = ibRange > 0 ? (ibC - ibL) / ibRange : 0.5
            
            // Buy vol = volume * close position (closes high = more buying)
            // Sell vol = volume * (1 - close position)
            float ibBuyV = ibV * ibClosePos
            float ibSellV = ibV * (1 - ibClosePos)
            
            // Direction bias adjustment
            if ibBullish
                ibBuyV := ibBuyV * 1.2
                ibSellV := ibSellV * 0.8
            else if ibBearish
                ibSellV := ibSellV * 1.2
                ibBuyV := ibBuyV * 0.8
            
            intrabarBuyVol := intrabarBuyVol + ibBuyV
            intrabarSellVol := intrabarSellVol + ibSellV
            
            // â•â•â• INTRABAR MOMENTUM â•â•â•
            if ibBullish
                intrabarBullCount := intrabarBullCount + 1
            else if ibBearish
                intrabarBearCount := intrabarBearCount + 1
            
            // â•â•â• VOLUME DISTRIBUTION â•â•â•
            // Where did volume cluster within the parent bar?
            float ibMidpoint = (ibH + ibL) / 2
            if ibMidpoint >= topZone
                intrabarVolTop := intrabarVolTop + ibV
            else if ibMidpoint <= bottomZone
                intrabarVolBottom := intrabarVolBottom + ibV
            else
                intrabarVolMid := intrabarVolMid + ibV
            
            // â•â•â• INTERNAL SWEEP TRACKING â•â•â•
            if i == 0
                firstHigh := ibH
                firstLow := ibL
            if i == arrSize - 1
                lastHigh := ibH
                lastLow := ibL
            
            // Check for internal sweep (price swept early high/low then reversed)
            if i >= 2 and i < arrSize - 2
                // Track running high/low of first half
                float earlyHigh = na
                float earlyLow = na
                for j = 0 to math.floor(arrSize / 2)
                    if j < arrSize
                        earlyHigh := na(earlyHigh) ? array.get(ibHigh, j) : math.max(earlyHigh, array.get(ibHigh, j))
                        earlyLow := na(earlyLow) ? array.get(ibLow, j) : math.min(earlyLow, array.get(ibLow, j))
                
                // Check if late bars swept early levels
                if i > arrSize / 2
                    if ibH > nz(earlyHigh, high) and ibC < nz(earlyHigh, high)
                        sweptInternalHigh := true
                    if ibL < nz(earlyLow, low) and ibC > nz(earlyLow, low)
                        sweptInternalLow := true
        
        // â•â•â• CALCULATE FINAL INTRABAR METRICS â•â•â•
        
        // Delta calculation
        float totalIBVol = intrabarBuyVol + intrabarSellVol
        intrabarDelta := intrabarBuyVol - intrabarSellVol
        intrabarDeltaPct := totalIBVol > 0 ? math.max(intrabarBuyVol, intrabarSellVol) / totalIBVol : 0.5
        
        intrabarBullDominant := intrabarBuyVol > intrabarSellVol and intrabarDeltaPct >= deltaThreshold
        intrabarBearDominant := intrabarSellVol > intrabarBuyVol and intrabarDeltaPct >= deltaThreshold
        intrabarStrongDelta := intrabarDeltaPct >= 0.70
        intrabarExtremeDelta := intrabarDeltaPct >= 0.78
        
        // Momentum calculation
        int maxCount = math.max(intrabarBullCount, intrabarBearCount)
        intrabarMomentum := intrabarTotalBars > 0 ? maxCount / intrabarTotalBars : 0
        intrabarMomentumBull := intrabarBullCount > intrabarBearCount and intrabarMomentum >= intrabarMomentumMin
        intrabarMomentumBear := intrabarBearCount > intrabarBullCount and intrabarMomentum >= intrabarMomentumMin
        intrabarMomentumStrong := intrabarMomentum >= 0.75
        
        // Absorption detection
        // High volume but price didn't move much = institutions absorbing
        float volPerPoint = candlePoints > 0 ? volume / candlePoints : 0
        float avgVolPerPoint = ta.sma(volPerPoint, 20)
        bool highVolLowMove = volPerPoint > avgVolPerPoint * 1.5 and candlePoints < avgRange / syminfo.mintick * 0.6
        
        // Volume clustering = absorption signature
        float maxVolZone = math.max(intrabarVolTop, math.max(intrabarVolMid, intrabarVolBottom))
        float volClusterPct = totalIBVol > 0 ? maxVolZone / totalIBVol : 0
        
        intrabarAbsorption := highVolLowMove and volClusterPct >= absorptionThreshold
        intrabarAbsorptionScore := volClusterPct
        
        // Determine absorption direction
        if intrabarAbsorption
            if intrabarVolBottom > intrabarVolTop and intrabarBuyVol > intrabarSellVol
                intrabarBullAbsorption := true  // Buying at lows = bullish absorption
                intrabarBearAbsorption := false
            else if intrabarVolTop > intrabarVolBottom and intrabarSellVol > intrabarBuyVol
                intrabarBearAbsorption := true  // Selling at highs = bearish absorption
                intrabarBullAbsorption := false
        
        // Volume cluster label
        intrabarVolCluster := intrabarVolTop > intrabarVolMid and intrabarVolTop > intrabarVolBottom ? "TOP" :
                             intrabarVolBottom > intrabarVolMid and intrabarVolBottom > intrabarVolTop ? "BOT" : "MID"
        
        // Internal sweep detection
        intrabarBullInternalSweep := sweptInternalLow and isBullish  // Swept lows, closed green = bull
        intrabarBearInternalSweep := sweptInternalHigh and isBearish // Swept highs, closed red = bear
        intrabarInternalSweep := intrabarBullInternalSweep or intrabarBearInternalSweep

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  DELTA ANALYSIS (STANDARD + INTRABAR)  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Standard delta estimation (fallback when intrabar not available)
float rng = high - low
float closePosition = rng > 0 ? (close - low) / rng : 0.5
float openPosition = rng > 0 ? (open - low) / rng : 0.5

float buyVol = volume * closePosition
float sellVol = volume * (1 - closePosition)

if isBullish
    buyVol := buyVol * 1.15
    sellVol := sellVol * 0.85
else if isBearish
    sellVol := sellVol * 1.15
    buyVol := buyVol * 0.85

var float cvd = 0.0
float barDelta = buyVol - sellVol
cvd := cvd + barDelta

float totalVol = buyVol + sellVol
float buyPct = totalVol > 0 ? buyVol / totalVol : 0.5
float sellPct = totalVol > 0 ? sellVol / totalVol : 0.5

// Use intrabar delta if available (more accurate)
float finalBuyPct = enableIntrabar and intrabarTotalBars > 0 ? 
     (intrabarBuyVol > intrabarSellVol ? intrabarDeltaPct : 1 - intrabarDeltaPct) : buyPct
float finalSellPct = enableIntrabar and intrabarTotalBars > 0 ? 
     (intrabarSellVol > intrabarBuyVol ? intrabarDeltaPct : 1 - intrabarDeltaPct) : sellPct

bool buyDominant = enableIntrabar and intrabarTotalBars > 0 ? intrabarBullDominant : finalBuyPct >= deltaThreshold
bool sellDominant = enableIntrabar and intrabarTotalBars > 0 ? intrabarBearDominant : finalSellPct >= deltaThreshold
bool strongDelta = enableIntrabar and intrabarTotalBars > 0 ? intrabarStrongDelta : (finalBuyPct >= 0.70 or finalSellPct >= 0.70)
bool extremeDelta = enableIntrabar and intrabarTotalBars > 0 ? intrabarExtremeDelta : (finalBuyPct >= 0.78 or finalSellPct >= 0.78)

// CVD analysis
float cvdMA = ta.sma(cvd, 5)
float cvdSlope = cvd - cvd[3]
bool cvdBullish = cvd > cvdMA and cvdSlope > 0
bool cvdBearish = cvd < cvdMA and cvdSlope < 0
bool cvdStrongBull = cvdBullish and cvdSlope > ta.stdev(cvdSlope, 10)
bool cvdStrongBear = cvdBearish and cvdSlope < -ta.stdev(cvdSlope, 10)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  SWING HIGH/LOW DETECTION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var array<float> swingHighs = array.new<float>()
var array<int> swingHighBars = array.new<int>()
var array<float> swingLows = array.new<float>()
var array<int> swingLowBars = array.new<int>()

bool isSwingHigh = high[2] > high[3] and high[2] > high[4] and high[2] > high[1] and high[2] > high[0]
bool isSwingLow = low[2] < low[3] and low[2] < low[4] and low[2] < low[1] and low[2] < low[0]

if isSwingHigh and barstate.isconfirmed
    array.push(swingHighs, high[2])
    array.push(swingHighBars, bar_index - 2)
    if array.size(swingHighs) > 20
        array.shift(swingHighs)
        array.shift(swingHighBars)

if isSwingLow and barstate.isconfirmed
    array.push(swingLows, low[2])
    array.push(swingLowBars, bar_index - 2)
    if array.size(swingLows) > 20
        array.shift(swingLows)
        array.shift(swingLowBars)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  LIQUIDITY SWEEP DETECTION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var int lastBullSweepBar = 0
var int lastBearSweepBar = 0
var float lastBullSweepLevel = na
var float lastBearSweepLevel = na

bool bullishSweep = false
bool bearishSweep = false

if array.size(swingHighs) > 0
    for i = array.size(swingHighs) - 1 to math.max(0, array.size(swingHighs) - 5)
        float swingLevel = array.get(swingHighs, i)
        int swingBar = array.get(swingHighBars, i)
        int barsAgo = bar_index - swingBar
        
        if barsAgo >= 3 and barsAgo <= swingLookback
            if high > swingLevel and close < swingLevel and hasUpperRejection and sellDominant
                bearishSweep := true
                lastBearSweepBar := bar_index
                lastBearSweepLevel := swingLevel
                break

if array.size(swingLows) > 0
    for i = array.size(swingLows) - 1 to math.max(0, array.size(swingLows) - 5)
        float swingLevel = array.get(swingLows, i)
        int swingBar = array.get(swingLowBars, i)
        int barsAgo = bar_index - swingBar
        
        if barsAgo >= 3 and barsAgo <= swingLookback
            if low < swingLevel and close > swingLevel and hasLowerRejection and buyDominant
                bullishSweep := true
                lastBullSweepBar := bar_index
                lastBullSweepLevel := swingLevel
                break

bool recentBullSweep = (bar_index - lastBullSweepBar) <= maxSweepAge
bool recentBearSweep = (bar_index - lastBearSweepBar) <= maxSweepAge

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  ORDER BLOCK DETECTION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

type OrderBlock
    float priceTop
    float priceBottom
    bool isBullish
    int barIdx
    int state
    float strength
    bool hasBeenSwept

var array<OrderBlock> orderBlocks = array.new<OrderBlock>()
var array<box> obBoxes = array.new<box>()

bool bullOBCondition = false
float bullOBTop = na
float bullOBBottom = na
float bullOBStrength = 0.0

if barstate.isconfirmed and bar_index > obLookback
    if close[1] < open[1]
        float moveAfter = close - close[1]
        float moveATR = moveAfter / atr
        
        if moveATR >= obMinStrength and isBullish and hasVolume
            bullOBCondition := true
            bullOBTop := high[1]
            bullOBBottom := low[1]
            
            float obVolRatio = volume[1] / avgVol
            float obBodyRatio = math.abs(close[1] - open[1]) / (high[1] - low[1])
            bullOBStrength := math.min(10, moveATR * 2 + obVolRatio + (obBodyRatio * 2))

bool bearOBCondition = false
float bearOBTop = na
float bearOBBottom = na
float bearOBStrength = 0.0

if barstate.isconfirmed and bar_index > obLookback
    if close[1] > open[1]
        float moveAfter = close[1] - close
        float moveATR = moveAfter / atr
        
        if moveATR >= obMinStrength and isBearish and hasVolume
            bearOBCondition := true
            bearOBTop := high[1]
            bearOBBottom := low[1]
            
            float obVolRatio = volume[1] / avgVol
            float obBodyRatio = math.abs(close[1] - open[1]) / (high[1] - low[1])
            bearOBStrength := math.min(10, moveATR * 2 + obVolRatio + (obBodyRatio * 2))

if showOrderBlocks and bullOBCondition and bullOBStrength >= 4
    OrderBlock newOB = OrderBlock.new()
    newOB.priceTop := bullOBTop
    newOB.priceBottom := bullOBBottom
    newOB.isBullish := true
    newOB.barIdx := bar_index - 1
    newOB.state := 0
    newOB.strength := bullOBStrength
    newOB.hasBeenSwept := false
    
    box obBox = box.new(
         left=bar_index - 1,
         top=bullOBTop,
         right=bar_index + EXTEND_BARS,
         bottom=bullOBBottom,
         border_color=color.new(#2196F3, 50),
         bgcolor=bullOBColor,
         border_width=2,
         border_style=line.style_solid)
    
    array.push(orderBlocks, newOB)
    array.push(obBoxes, obBox)

if showOrderBlocks and bearOBCondition and bearOBStrength >= 4
    OrderBlock newOB = OrderBlock.new()
    newOB.priceTop := bearOBTop
    newOB.priceBottom := bearOBBottom
    newOB.isBullish := false
    newOB.barIdx := bar_index - 1
    newOB.state := 0
    newOB.strength := bearOBStrength
    newOB.hasBeenSwept := false
    
    box obBox = box.new(
         left=bar_index - 1,
         top=bearOBTop,
         right=bar_index + EXTEND_BARS,
         bottom=bearOBBottom,
         border_color=color.new(#E91E63, 50),
         bgcolor=bearOBColor,
         border_width=2,
         border_style=line.style_solid)
    
    array.push(orderBlocks, newOB)
    array.push(obBoxes, obBox)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  FVG & IFVG ZONE DETECTION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

type FVGZone
    float priceTop
    float priceBottom
    bool isBullish
    int barIdx
    int state
    float quality
    bool isIFVG
    bool alignedWithOB

var array<FVGZone> fvgZones = array.new<FVGZone>()
var array<box> fvgBoxes = array.new<box>()
var array<line> fvgLines = array.new<line>()

bool fvgBullRaw = low > high[2]
bool fvgBearRaw = high < low[2]

float bullGapSize = fvgBullRaw ? (low - high[2]) : 0
float bearGapSize = fvgBearRaw ? (low[2] - high) : 0

bool gapSizeOK_Bull = bullGapSize >= atr * minGapATR
bool gapSizeOK_Bear = bearGapSize >= atr * minGapATR

float prevBodyRatio = (high[1] - low[1]) > 0 ? math.abs(close[1] - open[1]) / (high[1] - low[1]) : 0
float impulseStrength = candleRange[1] / avgRange
bool impulseOK = impulseStrength >= 1.3 and prevBodyRatio >= 0.65

calcFVGQuality(float gapSize, float impulseStr, float volR, bool hasOBAlign, bool inSess, bool hasIBConfirm) =>
    float q = 0.0
    q += math.min(2.5, (gapSize / atr) * 5)
    q += math.min(2.5, (impulseStr - 1) * 2)
    q += math.min(2.0, (volR - 1) * 1.5)
    q += hasOBAlign ? 2.0 : 0.0
    q += inSess ? 1.0 : 0.0
    q += hasIBConfirm ? 1.0 : 0.0  // Intrabar confirmation bonus
    math.min(10.0, q)

checkOBAlignment(float top, float bottom, bool bullish) =>
    bool aligned = false
    if array.size(orderBlocks) > 0
        for i = 0 to math.min(array.size(orderBlocks) - 1, 10)
            OrderBlock ob = array.get(orderBlocks, i)
            if ob.isBullish == bullish
                bool overlaps = not (bottom > ob.priceTop or top < ob.priceBottom)
                if overlaps
                    aligned := true
                    break
    aligned

// Intrabar confirmation for FVG
bool ibConfirmBullFVG = enableIntrabar and intrabarMomentumBull and intrabarBullDominant
bool ibConfirmBearFVG = enableIntrabar and intrabarMomentumBear and intrabarBearDominant

bool validBullFVG = fvgBullRaw and gapSizeOK_Bull and impulseOK and volume[1] >= avgVol and close[1] > open[1]
bool validBearFVG = fvgBearRaw and gapSizeOK_Bear and impulseOK and volume[1] >= avgVol and close[1] < open[1]

var bool ifvgBull = false
var bool ifvgBear = false
var float ifvgBullTop = na
var float ifvgBullBottom = na
var float ifvgBearTop = na
var float ifvgBearBottom = na

ifvgBull := false
ifvgBear := false

if array.size(fvgZones) > 0
    for i = array.size(fvgZones) - 1 to 0
        if i >= array.size(fvgZones)
            continue
        FVGZone zone = array.get(fvgZones, i)
        
        if not zone.isBullish and not zone.isIFVG and zone.state == 1
            if close > zone.priceTop and buyDominant and hasVolume
                ifvgBull := true
                ifvgBullTop := zone.priceTop
                ifvgBullBottom := zone.priceBottom
        
        if zone.isBullish and not zone.isIFVG and zone.state == 1
            if close < zone.priceBottom and sellDominant and hasVolume
                ifvgBear := true
                ifvgBearTop := zone.priceTop
                ifvgBearBottom := zone.priceBottom

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  CREATE FVG/IFVG ZONES  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if showFVG and barstate.isconfirmed
    if validBullFVG
        float topPrice = low
        float bottomPrice = high[2]
        float entry = (topPrice + bottomPrice) / 2
        bool obAlign = checkOBAlignment(topPrice, bottomPrice, true)
        float quality = calcFVGQuality(bullGapSize, impulseStrength, volRatio[1], obAlign, sessionOK, ibConfirmBullFVG)
        
        if quality >= zoneQualityMin
            FVGZone newZone = FVGZone.new()
            newZone.priceTop := topPrice
            newZone.priceBottom := bottomPrice
            newZone.isBullish := true
            newZone.barIdx := bar_index
            newZone.state := 0
            newZone.quality := quality
            newZone.isIFVG := false
            newZone.alignedWithOB := obAlign
            
            color zoneColor = obAlign ? color.new(#00E676, 70) : bullFVGColor
            int borderWidth = obAlign ? 2 : 1
            
            box zoneBox = box.new(
                 left=bar_index - 2,
                 top=topPrice,
                 right=bar_index + EXTEND_BARS,
                 bottom=bottomPrice,
                 border_color=color.new(#00E676, 40),
                 bgcolor=zoneColor,
                 border_width=borderWidth)
            line entryLine = line.new(
                 x1=bar_index - 2,
                 y1=entry,
                 x2=bar_index + EXTEND_BARS,
                 y2=entry,
                 color=color.new(#FFFFFF, 60),
                 style=line.style_dotted,
                 width=1)
            
            array.push(fvgZones, newZone)
            array.push(fvgBoxes, zoneBox)
            array.push(fvgLines, entryLine)
    
    if validBearFVG
        float topPrice = low[2]
        float bottomPrice = high
        float entry = (topPrice + bottomPrice) / 2
        bool obAlign = checkOBAlignment(topPrice, bottomPrice, false)
        float quality = calcFVGQuality(bearGapSize, impulseStrength, volRatio[1], obAlign, sessionOK, ibConfirmBearFVG)
        
        if quality >= zoneQualityMin
            FVGZone newZone = FVGZone.new()
            newZone.priceTop := topPrice
            newZone.priceBottom := bottomPrice
            newZone.isBullish := false
            newZone.barIdx := bar_index
            newZone.state := 0
            newZone.quality := quality
            newZone.isIFVG := false
            newZone.alignedWithOB := obAlign
            
            color zoneColor = obAlign ? color.new(#FF5252, 70) : bearFVGColor
            int borderWidth = obAlign ? 2 : 1
            
            box zoneBox = box.new(
                 left=bar_index - 2,
                 top=topPrice,
                 right=bar_index + EXTEND_BARS,
                 bottom=bottomPrice,
                 border_color=color.new(#FF5252, 40),
                 bgcolor=zoneColor,
                 border_width=borderWidth)
            line entryLine = line.new(
                 x1=bar_index - 2,
                 y1=entry,
                 x2=bar_index + EXTEND_BARS,
                 y2=entry,
                 color=color.new(#FFFFFF, 60),
                 style=line.style_dotted,
                 width=1)
            
            array.push(fvgZones, newZone)
            array.push(fvgBoxes, zoneBox)
            array.push(fvgLines, entryLine)

if showIFVG and barstate.isconfirmed
    if ifvgBull and not na(ifvgBullTop)
        float entry = (ifvgBullTop + ifvgBullBottom) / 2
        
        FVGZone newZone = FVGZone.new()
        newZone.priceTop := ifvgBullTop
        newZone.priceBottom := ifvgBullBottom
        newZone.isBullish := true
        newZone.barIdx := bar_index
        newZone.state := 0
        newZone.quality := 8.0
        newZone.isIFVG := true
        newZone.alignedWithOB := false
        
        box zoneBox = box.new(
             left=bar_index,
             top=ifvgBullTop,
             right=bar_index + EXTEND_BARS,
             bottom=ifvgBullBottom,
             border_color=color.new(#9C27B0, 30),
             bgcolor=ifvgColor,
             border_width=2,
             border_style=line.style_dashed)
        line entryLine = line.new(
             x1=bar_index,
             y1=entry,
             x2=bar_index + EXTEND_BARS,
             y2=entry,
             color=color.new(#9C27B0, 40),
             style=line.style_dotted,
             width=1)
        
        array.push(fvgZones, newZone)
        array.push(fvgBoxes, zoneBox)
        array.push(fvgLines, entryLine)
    
    if ifvgBear and not na(ifvgBearTop)
        float entry = (ifvgBearTop + ifvgBearBottom) / 2
        
        FVGZone newZone = FVGZone.new()
        newZone.priceTop := ifvgBearTop
        newZone.priceBottom := ifvgBearBottom
        newZone.isBullish := false
        newZone.barIdx := bar_index
        newZone.state := 0
        newZone.quality := 8.0
        newZone.isIFVG := true
        newZone.alignedWithOB := false
        
        box zoneBox = box.new(
             left=bar_index,
             top=ifvgBearTop,
             right=bar_index + EXTEND_BARS,
             bottom=ifvgBearBottom,
             border_color=color.new(#9C27B0, 30),
             bgcolor=ifvgColor,
             border_width=2,
             border_style=line.style_dashed)
        line entryLine = line.new(
             x1=bar_index,
             y1=entry,
             x2=bar_index + EXTEND_BARS,
             y2=entry,
             color=color.new(#9C27B0, 40),
             style=line.style_dotted,
             width=1)
        
        array.push(fvgZones, newZone)
        array.push(fvgBoxes, zoneBox)
        array.push(fvgLines, entryLine)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  ZONE STATE MANAGEMENT  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var bool atBullZone = false
var bool atBearZone = false
var bool atBullOB = false
var bool atBearOB = false
var bool atIFVG = false
var float currentZoneQuality = 0.0

atBullZone := false
atBearZone := false
atBullOB := false
atBearOB := false
atIFVG := false
currentZoneQuality := 0.0

if array.size(fvgZones) > 0
    for i = array.size(fvgZones) - 1 to 0
        if i >= array.size(fvgZones)
            continue
            
        FVGZone zone = array.get(fvgZones, i)
        int age = bar_index - zone.barIdx
        
        if age > maxZoneAge or zone.state >= 2
            if i < array.size(fvgBoxes)
                box.delete(array.get(fvgBoxes, i))
                array.remove(fvgBoxes, i)
            if i < array.size(fvgLines)
                line.delete(array.get(fvgLines, i))
                array.remove(fvgLines, i)
            array.remove(fvgZones, i)
            continue
        
        bool inZone = close >= zone.priceBottom and close <= zone.priceTop
        
        if zone.state < 2
            if zone.isBullish
                if inZone
                    atBullZone := true
                    currentZoneQuality := math.max(currentZoneQuality, zone.quality)
                    if zone.isIFVG
                        atIFVG := true
            else
                if inZone
                    atBearZone := true
                    currentZoneQuality := math.max(currentZoneQuality, zone.quality)
                    if zone.isIFVG
                        atIFVG := true
        
        float midPoint = (zone.priceTop + zone.priceBottom) / 2
        if zone.isBullish
            if zone.state == 0 and low <= midPoint
                zone.state := 1
                if i < array.size(fvgBoxes)
                    box.set_bgcolor(array.get(fvgBoxes, i), color.new(#78909C, 85))
            if zone.state < 2 and close < zone.priceBottom
                zone.state := 2
        else
            if zone.state == 0 and high >= midPoint
                zone.state := 1
                if i < array.size(fvgBoxes)
                    box.set_bgcolor(array.get(fvgBoxes, i), color.new(#78909C, 85))
            if zone.state < 2 and close > zone.priceTop
                zone.state := 2

if array.size(orderBlocks) > 0
    for i = array.size(orderBlocks) - 1 to 0
        if i >= array.size(orderBlocks)
            continue
            
        OrderBlock ob = array.get(orderBlocks, i)
        int age = bar_index - ob.barIdx
        
        if age > maxZoneAge or ob.state >= 2
            if i < array.size(obBoxes)
                box.delete(array.get(obBoxes, i))
                array.remove(obBoxes, i)
            array.remove(orderBlocks, i)
            continue
        
        bool inOB = close >= ob.priceBottom and close <= ob.priceTop
        
        if ob.state < 2
            if ob.isBullish and inOB
                atBullOB := true
            else if not ob.isBullish and inOB
                atBearOB := true
        
        float midPoint = (ob.priceTop + ob.priceBottom) / 2
        if ob.isBullish
            if ob.state == 0 and low <= midPoint
                ob.state := 1
                if i < array.size(obBoxes)
                    box.set_bgcolor(array.get(obBoxes, i), color.new(#2196F3, 85))
            if ob.state < 2 and close < ob.priceBottom
                ob.state := 2
        else
            if ob.state == 0 and high >= midPoint
                ob.state := 1
                if i < array.size(obBoxes)
                    box.set_bgcolor(array.get(obBoxes, i), color.new(#E91E63, 85))
            if ob.state < 2 and close > ob.priceTop
                ob.state := 2

while array.size(fvgZones) > maxZones
    if array.size(fvgBoxes) > 0
        box.delete(array.get(fvgBoxes, 0))
        array.remove(fvgBoxes, 0)
    if array.size(fvgLines) > 0
        line.delete(array.get(fvgLines, 0))
        array.remove(fvgLines, 0)
    if array.size(fvgZones) > 0
        array.remove(fvgZones, 0)

while array.size(orderBlocks) > maxOrderBlocks
    if array.size(obBoxes) > 0
        box.delete(array.get(obBoxes, 0))
        array.remove(obBoxes, 0)
    if array.size(orderBlocks) > 0
        array.remove(orderBlocks, 0)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  CONFLUENCE SCORING (ENHANCED WITH INTRABAR)  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool confirmedLong = isBullish and buyDominant
bool confirmedShort = isBearish and sellDominant

bool cvdConfirmLong = not requireCVDConfirm or cvdBullish
bool cvdConfirmShort = not requireCVDConfirm or cvdBearish

// Intrabar confirmation for base signal
bool intrabarConfirmLong = not enableIntrabar or (intrabarBullDominant and (intrabarMomentumBull or intrabarBullAbsorption))
bool intrabarConfirmShort = not enableIntrabar or (intrabarBearDominant and (intrabarMomentumBear or intrabarBearAbsorption))

// Base signal requirements
bool baseLong = isTiered and hasVolume and confirmedLong and hasStrongBody and hasSignificantRange and wicksOK and cvdConfirmLong and sessionOK
bool baseShort = isTiered and hasVolume and confirmedShort and hasStrongBody and hasSignificantRange and wicksOK and cvdConfirmShort and sessionOK

// Enhanced Confluence Scoring (max ~14, normalized to 10)
float longConfluence = 0.0
float shortConfluence = 0.0

if baseLong
    longConfluence := tierScore                                    // S=3, A=2, B=1
    longConfluence += atBullZone ? 1.5 : 0.0                       // In FVG zone
    longConfluence += atBullOB ? 1.5 : 0.0                         // In Order Block
    longConfluence += atIFVG ? 1.0 : 0.0                           // In IFVG (bonus)
    longConfluence += hasStrongVolume ? 1.0 : 0.0                  // Strong volume (2x+)
    longConfluence += hasExtremeVolume ? 0.5 : 0.0                 // Extreme volume (2.5x+)
    longConfluence += strongDelta ? 1.0 : 0.0                      // Strong delta (70%+)
    longConfluence += extremeDelta ? 0.5 : 0.0                     // Extreme delta (78%+)
    longConfluence += cvdStrongBull ? 1.0 : (cvdBullish ? 0.5 : 0.0)  // CVD momentum
    longConfluence += recentBullSweep ? 1.5 : 0.0                  // Liquidity sweep confirmation
    
    // â•â•â• INTRABAR CONFLUENCE ADDITIONS â•â•â•
    if enableIntrabar and intrabarTotalBars > 0
        // Intrabar delta confirmation (stronger than estimated)
        float ibDeltaBonus = intrabarBullDominant ? (intrabarStrongDelta ? intrabarDeltaWeight : intrabarDeltaWeight * 0.6) : 0.0
        longConfluence += ibDeltaBonus
        
        // Intrabar momentum (consistent direction within bar)
        longConfluence += intrabarMomentumBull ? (intrabarMomentumStrong ? 1.0 : 0.5) : 0.0
        
        // Absorption bonus (institutions accumulating)
        longConfluence += intrabarBullAbsorption ? absorptionWeight : 0.0
        
        // Internal sweep bonus (hidden liquidity grab)
        longConfluence += intrabarBullInternalSweep ? 1.0 : 0.0
        
        // Volume cluster bonus (volume at bottom = buying at lows)
        longConfluence += intrabarVolCluster == "BOT" ? 0.5 : 0.0
    
    // Normalize to 10
    longConfluence := math.min(10.0, longConfluence * 0.72)

if baseShort
    shortConfluence := tierScore
    shortConfluence += atBearZone ? 1.5 : 0.0
    shortConfluence += atBearOB ? 1.5 : 0.0
    shortConfluence += atIFVG ? 1.0 : 0.0
    shortConfluence += hasStrongVolume ? 1.0 : 0.0
    shortConfluence += hasExtremeVolume ? 0.5 : 0.0
    shortConfluence += strongDelta ? 1.0 : 0.0
    shortConfluence += extremeDelta ? 0.5 : 0.0
    shortConfluence += cvdStrongBear ? 1.0 : (cvdBearish ? 0.5 : 0.0)
    shortConfluence += recentBearSweep ? 1.5 : 0.0
    
    // â•â•â• INTRABAR CONFLUENCE ADDITIONS â•â•â•
    if enableIntrabar and intrabarTotalBars > 0
        // Intrabar delta confirmation
        float ibDeltaBonus = intrabarBearDominant ? (intrabarStrongDelta ? intrabarDeltaWeight : intrabarDeltaWeight * 0.6) : 0.0
        shortConfluence += ibDeltaBonus
        
        // Intrabar momentum
        shortConfluence += intrabarMomentumBear ? (intrabarMomentumStrong ? 1.0 : 0.5) : 0.0
        
        // Absorption bonus
        shortConfluence += intrabarBearAbsorption ? absorptionWeight : 0.0
        
        // Internal sweep bonus
        shortConfluence += intrabarBearInternalSweep ? 1.0 : 0.0
        
        // Volume cluster bonus (volume at top = selling at highs)
        shortConfluence += intrabarVolCluster == "TOP" ? 0.5 : 0.0
    
    shortConfluence := math.min(10.0, shortConfluence * 0.72)

// Score classification
string longScoreClass = longConfluence >= minScoreExcellent ? "EXCELLENT" : longConfluence >= minScoreWeak ? "MEDIUM" : "WEAK"
string shortScoreClass = shortConfluence >= minScoreExcellent ? "EXCELLENT" : shortConfluence >= minScoreWeak ? "MEDIUM" : "WEAK"

// Final signals (require at least MEDIUM score)
bool longSignal = baseLong and longConfluence >= minScoreWeak
bool shortSignal = baseShort and shortConfluence >= minScoreWeak

bool sLong = longSignal and isTierS
bool aLong = longSignal and isTierA
bool bLong = longSignal and isTierB

bool sShort = shortSignal and isTierS
bool aShort = shortSignal and isTierA
bool bShort = shortSignal and isTierB

// Zone entry signals
bool dfzBuyEntry = (atBullZone or atBullOB) and buyDominant and hasVolume and sessionOK and not longSignal and currentZoneQuality >= 6.0
bool dfzSellEntry = (atBearZone or atBearOB) and sellDominant and hasVolume and sessionOK and not shortSignal and currentZoneQuality >= 6.0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  STOP/TARGET CALCULATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float longStop = na
float shortStop = na
float longTarget = na
float shortTarget = na

if longSignal
    longStop := low - TICK_VALUE * 2
    float riskPts = close - longStop
    float rewardMult = isTierS ? 2.5 : isTierA ? 2.0 : 1.5
    if longConfluence >= minScoreExcellent
        rewardMult += 0.5
    // Intrabar absorption = stronger conviction = better R:R
    if enableIntrabar and intrabarBullAbsorption
        rewardMult += 0.3
    longTarget := close + (riskPts * rewardMult)

if shortSignal
    shortStop := high + TICK_VALUE * 2
    float riskPts = shortStop - close
    float rewardMult = isTierS ? 2.5 : isTierA ? 2.0 : 1.5
    if shortConfluence >= minScoreExcellent
        rewardMult += 0.5
    if enableIntrabar and intrabarBearAbsorption
        rewardMult += 0.3
    shortTarget := close - (riskPts * rewardMult)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  VISUALIZATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Tier Signal Markers
plotshape(sLong, "S Long", shape.triangleup, location.belowbar, sTierColor, size=size.normal, text="SğŸ¯", textcolor=color.white)
plotshape(aLong, "A Long", shape.triangleup, location.belowbar, aTierColor, size=size.small, text="AğŸ¯", textcolor=color.white)
plotshape(bLong, "B Long", shape.triangleup, location.belowbar, bTierColor, size=size.tiny, text="BğŸ¯", textcolor=color.white)

plotshape(sShort, "S Short", shape.triangledown, location.abovebar, sTierColor, size=size.normal, text="SğŸ¯", textcolor=color.white)
plotshape(aShort, "A Short", shape.triangledown, location.abovebar, aTierColor, size=size.small, text="AğŸ¯", textcolor=color.white)
plotshape(bShort, "B Short", shape.triangledown, location.abovebar, bTierColor, size=size.tiny, text="BğŸ¯", textcolor=color.white)

// Zone Entry Signals
plotshape(dfzBuyEntry, "Zone Buy", shape.labelup, location.belowbar, color.new(#00E676, 0), text="Z", textcolor=color.white, size=size.tiny)
plotshape(dfzSellEntry, "Zone Sell", shape.labeldown, location.abovebar, color.new(#FF5252, 0), text="Z", textcolor=color.white, size=size.tiny)

// Liquidity Sweep Markers
plotshape(showLiqSweeps and bullishSweep, "Bull Sweep", shape.diamond, location.belowbar, sweepBullColor, size=size.small, text="LSâ†‘", textcolor=color.white)
plotshape(showLiqSweeps and bearishSweep, "Bear Sweep", shape.diamond, location.abovebar, sweepBearColor, size=size.small, text="LSâ†“", textcolor=color.white)

// Intrabar Internal Sweep Markers (hidden sweeps inside candle)
plotshape(enableIntrabar and intrabarBullInternalSweep and not bullishSweep, "IB Bull Sweep", shape.circle, location.belowbar, intrabarBullColor, size=size.tiny, text="iS", textcolor=color.white)
plotshape(enableIntrabar and intrabarBearInternalSweep and not bearishSweep, "IB Bear Sweep", shape.circle, location.abovebar, intrabarBearColor, size=size.tiny, text="iS", textcolor=color.white)

// Absorption Markers
plotshape(enableIntrabar and intrabarBullAbsorption, "Bull Absorption", shape.xcross, location.belowbar, intrabarBullColor, size=size.tiny)
plotshape(enableIntrabar and intrabarBearAbsorption, "Bear Absorption", shape.xcross, location.abovebar, intrabarBearColor, size=size.tiny)

// Session Markers
plotshape(londonStart, "LDN", shape.circle, location.abovebar, color.new(#2196F3, 0), size=size.tiny)
plotshape(nyStart, "NY", shape.circle, location.abovebar, color.new(#4CAF50, 0), size=size.tiny)
plotshape(powerHourStart, "PWR", shape.circle, location.abovebar, color.new(#FF9800, 0), size=size.tiny)

// Session backgrounds
bgcolor(inLondon ? color.new(#2196F3, 95) : na, title="London BG")
bgcolor(inNY ? color.new(#4CAF50, 95) : na, title="NY BG")
bgcolor(inPowerHour ? color.new(#FF9800, 95) : na, title="Power Hour BG")

// Stop/Target lines
plot(longSignal ? longStop : na, "Long Stop", color.new(#FF5252, 0), 2, plot.style_linebr)
plot(longSignal ? longTarget : na, "Long Target", color.new(#00E676, 0), 2, plot.style_linebr)
plot(shortSignal ? shortStop : na, "Short Stop", color.new(#FF5252, 0), 2, plot.style_linebr)
plot(shortSignal ? shortTarget : na, "Short Target", color.new(#00E676, 0), 2, plot.style_linebr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  ENHANCED INFO TABLE v7  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

tablePosition = switch tablePos
    "Top Right" => position.top_right
    "Top Left" => position.top_left
    "Bottom Right" => position.bottom_right
    "Bottom Left" => position.bottom_left
    "Top Center" => position.top_center
    "Bottom Center" => position.bottom_center
    => position.top_right

tSize = switch tableSize
    "tiny" => size.tiny
    "small" => size.small
    "normal" => size.normal
    "large" => size.large
    => size.normal

tSizeSmall = switch tableSize
    "tiny" => size.tiny
    "small" => size.tiny
    "normal" => size.small
    "large" => size.normal
    => size.small

// Create enhanced table (3 columns, 18 rows for intrabar section)
int tableRows = showIntrabarMetrics and enableIntrabar ? 18 : 14
var table panel = table.new(tablePosition, 3, tableRows, 
     bgcolor=color.new(#0d1117, tableTransparency), 
     border_width=2, 
     border_color=color.new(#30363d, 0),
     frame_width=2,
     frame_color=color.new(#58a6ff, 30))

if barstate.islast
    color tierCol = isTierS ? sTierColor : isTierA ? aTierColor : isTierB ? bTierColor : color.gray
    float activeScore = longSignal ? longConfluence : shortSignal ? shortConfluence : math.max(baseLong ? longConfluence : 0, baseShort ? shortConfluence : 0)
    string activeScoreClass = activeScore >= minScoreExcellent ? "EXCELLENT" : activeScore >= minScoreWeak ? "MEDIUM" : "WEAK"
    
    // Header
    table.cell(panel, 0, 0, "YM SNIPER", text_color=color.white, text_size=tSize, bgcolor=color.new(#58a6ff, 20))
    table.cell(panel, 1, 0, "v7", text_color=#58a6ff, text_size=tSize, bgcolor=color.new(#58a6ff, 20))
    table.cell(panel, 2, 0, "ğŸ¯", text_color=color.white, text_size=tSize, bgcolor=color.new(#58a6ff, 20))
    
    // â•â•â• CANDLE SECTION â•â•â•
    table.cell(panel, 0, 1, "â•â• CANDLE â•â•", text_color=color.new(#8b949e, 0), text_size=tSizeSmall, bgcolor=color.new(#21262d, 0))
    table.merge_cells(panel, 0, 1, 2, 1)
    
    table.cell(panel, 0, 2, "Points", text_color=#8b949e, text_size=tSizeSmall, bgcolor=color.new(#161b22, 0))
    table.cell(panel, 1, 2, str.tostring(candlePoints, "#.#"), text_color=tierCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
    table.cell(panel, 2, 2, tier, text_color=tierCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
    
    color vCol = hasExtremeVolume ? #00ff00 : hasStrongVolume ? #00E676 : hasVolume ? #4CAF50 : #f85149
    table.cell(panel, 0, 3, "Volume", text_color=#8b949e, text_size=tSizeSmall, bgcolor=color.new(#161b22, 0))
    table.cell(panel, 1, 3, str.tostring(volRatio, "#.##") + "x", text_color=vCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
    string volGrade = hasExtremeVolume ? "ğŸ”¥" : hasStrongVolume ? "âœ“âœ“" : hasVolume ? "âœ“" : "âœ—"
    table.cell(panel, 2, 3, volGrade, text_color=vCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
    
    // â•â•â• ORDERFLOW SECTION â•â•â•
    table.cell(panel, 0, 4, "â•â• ORDERFLOW â•â•", text_color=color.new(#8b949e, 0), text_size=tSizeSmall, bgcolor=color.new(#21262d, 0))
    table.merge_cells(panel, 0, 4, 2, 4)
    
    // Use intrabar delta if available
    float displayBuyPct = enableIntrabar and intrabarTotalBars > 0 ? (intrabarBuyVol / (intrabarBuyVol + intrabarSellVol)) : buyPct
    float displaySellPct = enableIntrabar and intrabarTotalBars > 0 ? (intrabarSellVol / (intrabarBuyVol + intrabarSellVol)) : sellPct
    
    string dStr = displayBuyPct > displaySellPct ? str.tostring(displayBuyPct * 100, "#") + "% BUY" : str.tostring(displaySellPct * 100, "#") + "% SELL"
    color dCol = extremeDelta ? (displayBuyPct > displaySellPct ? #00ff00 : #ff0000) : strongDelta ? (displayBuyPct > displaySellPct ? #00E676 : #f85149) : buyDominant ? #4CAF50 : sellDominant ? #da3633 : #8b949e
    table.cell(panel, 0, 5, "Delta", text_color=#8b949e, text_size=tSizeSmall, bgcolor=color.new(#161b22, 0))
    table.cell(panel, 1, 5, dStr, text_color=dCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
    string deltaGrade = extremeDelta ? "ğŸ”¥" : strongDelta ? "âœ“âœ“" : (buyDominant or sellDominant) ? "âœ“" : "â€”"
    table.cell(panel, 2, 5, deltaGrade, text_color=dCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
    
    color cvdCol = cvdStrongBull ? #00ff00 : cvdStrongBear ? #ff0000 : cvdBullish ? #00E676 : cvdBearish ? #f85149 : #8b949e
    string cvdDir = cvdStrongBull ? "â–²â–² STRONG" : cvdStrongBear ? "â–¼â–¼ STRONG" : cvdBullish ? "â–² UP" : cvdBearish ? "â–¼ DOWN" : "â€” FLAT"
    table.cell(panel, 0, 6, "CVD", text_color=#8b949e, text_size=tSizeSmall, bgcolor=color.new(#161b22, 0))
    table.cell(panel, 1, 6, cvdDir, text_color=cvdCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
    table.cell(panel, 2, 6, "", text_color=cvdCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
    
    // â•â•â• INTRABAR SECTION (NEW) â•â•â•
    int rowOffset = 0
    if showIntrabarMetrics and enableIntrabar
        table.cell(panel, 0, 7, "â•â• INTRABAR â•â•", text_color=color.new(#00FF7F, 0), text_size=tSizeSmall, bgcolor=color.new(#21262d, 0))
        table.merge_cells(panel, 0, 7, 2, 7)
        
        // Intrabar Delta
        string ibDeltaStr = intrabarBullDominant ? str.tostring(intrabarDeltaPct * 100, "#") + "% BUY" : 
                          intrabarBearDominant ? str.tostring(intrabarDeltaPct * 100, "#") + "% SELL" : "NEUTRAL"
        color ibDeltaCol = intrabarExtremeDelta ? (intrabarBullDominant ? #00ff00 : #ff0000) : 
                          intrabarStrongDelta ? (intrabarBullDominant ? #00E676 : #f85149) : 
                          intrabarBullDominant ? #4CAF50 : intrabarBearDominant ? #da3633 : #8b949e
        table.cell(panel, 0, 8, "IB Delta", text_color=#8b949e, text_size=tSizeSmall, bgcolor=color.new(#161b22, 0))
        table.cell(panel, 1, 8, ibDeltaStr, text_color=ibDeltaCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
        string ibDeltaGrade = intrabarExtremeDelta ? "ğŸ”¥" : intrabarStrongDelta ? "âœ“âœ“" : (intrabarBullDominant or intrabarBearDominant) ? "âœ“" : "â€”"
        table.cell(panel, 2, 8, ibDeltaGrade, text_color=ibDeltaCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
        
        // Intrabar Momentum
        string ibMomStr = intrabarMomentumBull ? str.tostring(intrabarMomentum * 100, "#") + "% BULL" :
                         intrabarMomentumBear ? str.tostring(intrabarMomentum * 100, "#") + "% BEAR" : "MIXED"
        color ibMomCol = intrabarMomentumStrong ? (intrabarMomentumBull ? #00ff00 : #ff0000) : intrabarMomentumBull ? #00E676 : intrabarMomentumBear ? #f85149 : #8b949e
        table.cell(panel, 0, 9, "IB Momentum", text_color=#8b949e, text_size=tSizeSmall, bgcolor=color.new(#161b22, 0))
        table.cell(panel, 1, 9, ibMomStr, text_color=ibMomCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
        table.cell(panel, 2, 9, intrabarMomentumStrong ? "ğŸ”¥" : (intrabarMomentumBull or intrabarMomentumBear) ? "âœ“" : "â€”", text_color=ibMomCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
        
        // Absorption
        string absStr = intrabarBullAbsorption ? "BULL ABS" : intrabarBearAbsorption ? "BEAR ABS" : "â€”"
        color absCol = intrabarAbsorption ? (intrabarBullAbsorption ? #00FF7F : #FF6B6B) : #8b949e
        table.cell(panel, 0, 10, "Absorption", text_color=#8b949e, text_size=tSizeSmall, bgcolor=color.new(#161b22, 0))
        table.cell(panel, 1, 10, absStr, text_color=absCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
        table.cell(panel, 2, 10, intrabarAbsorption ? "ğŸ¯" : "", text_color=absCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
        
        rowOffset := 4
    
    // â•â•â• STRUCTURE SECTION â•â•â•
    table.cell(panel, 0, 7 + rowOffset, "â•â• STRUCTURE â•â•", text_color=color.new(#8b949e, 0), text_size=tSizeSmall, bgcolor=color.new(#21262d, 0))
    table.merge_cells(panel, 0, 7 + rowOffset, 2, 7 + rowOffset)
    
    string zoneStatus = atIFVG ? "IFVG" : atBullZone ? "BULL FVG" : atBearZone ? "BEAR FVG" : "â€”"
    color zoneCol = atIFVG ? #9C27B0 : atBullZone ? #00E676 : atBearZone ? #f85149 : #8b949e
    table.cell(panel, 0, 8 + rowOffset, "FVG Zone", text_color=#8b949e, text_size=tSizeSmall, bgcolor=color.new(#161b22, 0))
    table.cell(panel, 1, 8 + rowOffset, zoneStatus, text_color=zoneCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
    table.cell(panel, 2, 8 + rowOffset, currentZoneQuality > 0 ? str.tostring(currentZoneQuality, "#.#") : "", text_color=zoneCol, text_size=tSizeSmall, bgcolor=color.new(#161b22, 0))
    
    string obStatus = atBullOB ? "BULL OB" : atBearOB ? "BEAR OB" : "â€”"
    color obCol = atBullOB ? #2196F3 : atBearOB ? #E91E63 : #8b949e
    table.cell(panel, 0, 9 + rowOffset, "Order Block", text_color=#8b949e, text_size=tSizeSmall, bgcolor=color.new(#161b22, 0))
    table.cell(panel, 1, 9 + rowOffset, obStatus, text_color=obCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
    table.cell(panel, 2, 9 + rowOffset, atBullOB or atBearOB ? "âœ“" : "", text_color=obCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
    
    string sweepStatus = recentBullSweep ? "BULL LSâ†‘" : recentBearSweep ? "BEAR LSâ†“" : intrabarBullInternalSweep ? "iSâ†‘" : intrabarBearInternalSweep ? "iSâ†“" : "â€”"
    color sweepCol = recentBullSweep ? sweepBullColor : recentBearSweep ? sweepBearColor : intrabarInternalSweep ? #00FF7F : #8b949e
    table.cell(panel, 0, 10 + rowOffset, "Liq Sweep", text_color=#8b949e, text_size=tSizeSmall, bgcolor=color.new(#161b22, 0))
    table.cell(panel, 1, 10 + rowOffset, sweepStatus, text_color=sweepCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
    table.cell(panel, 2, 10 + rowOffset, recentBullSweep or recentBearSweep ? "ğŸ¯" : intrabarInternalSweep ? "âš¡" : "", text_color=sweepCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
    
    // â•â•â• SIGNAL SECTION â•â•â•
    table.cell(panel, 0, 11 + rowOffset, "â•â• SIGNAL â•â•", text_color=color.new(#8b949e, 0), text_size=tSizeSmall, bgcolor=color.new(#21262d, 0))
    table.merge_cells(panel, 0, 11 + rowOffset, 2, 11 + rowOffset)
    
    color sCol = inSession ? #ffa657 : #8b949e
    table.cell(panel, 0, 12 + rowOffset, "Session", text_color=#8b949e, text_size=tSizeSmall, bgcolor=color.new(#161b22, 0))
    table.cell(panel, 1, 12 + rowOffset, currentSession, text_color=sCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
    table.cell(panel, 2, 12 + rowOffset, inSession ? "ğŸŸ¢" : "ğŸ”´", text_color=sCol, text_size=tSize, bgcolor=color.new(#161b22, 0))
    
    color scoreCol = activeScore >= minScoreExcellent ? #00ff00 : activeScore >= minScoreWeak ? #ffa657 : #f85149
    color scoreBg = activeScore >= minScoreExcellent ? color.new(#238636, 30) : activeScore >= minScoreWeak ? color.new(#9e6a03, 30) : color.new(#161b22, 0)
    table.cell(panel, 0, 13 + rowOffset, "SCORE", text_color=#8b949e, text_size=tSizeSmall, bgcolor=scoreBg)
    table.cell(panel, 1, 13 + rowOffset, str.tostring(activeScore, "#.#") + "/10", text_color=scoreCol, text_size=tSize, bgcolor=scoreBg)
    table.cell(panel, 2, 13 + rowOffset, activeScoreClass, text_color=scoreCol, text_size=tSizeSmall, bgcolor=scoreBg)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  ALERTS  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

alertcondition(sLong, title="ğŸ¯ S-TIER LONG", message="ğŸ¯ğŸ¥‡ S-TIER LONG {{ticker}} @ {{close}} | HOLD | Score: HIGH")
alertcondition(aLong, title="ğŸ¯ A-TIER LONG", message="ğŸ¯ğŸ¥ˆ A-TIER LONG {{ticker}} @ {{close}} | SWING")
alertcondition(bLong, title="ğŸ¯ B-TIER LONG", message="ğŸ¯ğŸ¥‰ B-TIER LONG {{ticker}} @ {{close}} | SCALP")

alertcondition(sShort, title="ğŸ¯ S-TIER SHORT", message="ğŸ¯ğŸ¥‡ S-TIER SHORT {{ticker}} @ {{close}} | HOLD | Score: HIGH")
alertcondition(aShort, title="ğŸ¯ A-TIER SHORT", message="ğŸ¯ğŸ¥ˆ A-TIER SHORT {{ticker}} @ {{close}} | SWING")
alertcondition(bShort, title="ğŸ¯ B-TIER SHORT", message="ğŸ¯ğŸ¥‰ B-TIER SHORT {{ticker}} @ {{close}} | SCALP")

alertcondition(dfzBuyEntry, title="ğŸ¯ ZONE BUY", message="ğŸŸ¢ ZONE BUY {{ticker}} @ {{close}} | Quality Zone Entry")
alertcondition(dfzSellEntry, title="ğŸ¯ ZONE SELL", message="ğŸ”´ ZONE SELL {{ticker}} @ {{close}} | Quality Zone Entry")

alertcondition(bullishSweep, title="ğŸ’ BULL LIQUIDITY SWEEP", message="ğŸ’ BULLISH SWEEP {{ticker}} @ {{close}} | Lows swept + rejection")
alertcondition(bearishSweep, title="ğŸ’ BEAR LIQUIDITY SWEEP", message="ğŸ’ BEARISH SWEEP {{ticker}} @ {{close}} | Highs swept + rejection")

// Intrabar specific alerts
alertcondition(intrabarBullInternalSweep, title="âš¡ INTRABAR BULL SWEEP", message="âš¡ INTRABAR BULL SWEEP {{ticker}} @ {{close}} | Hidden liquidity grab")
alertcondition(intrabarBearInternalSweep, title="âš¡ INTRABAR BEAR SWEEP", message="âš¡ INTRABAR BEAR SWEEP {{ticker}} @ {{close}} | Hidden liquidity grab")
alertcondition(intrabarBullAbsorption, title="ğŸ¯ BULL ABSORPTION", message="ğŸ¯ BULLISH ABSORPTION {{ticker}} @ {{close}} | Institutions accumulating")
alertcondition(intrabarBearAbsorption, title="ğŸ¯ BEAR ABSORPTION", message="ğŸ¯ BEARISH ABSORPTION {{ticker}} @ {{close}} | Institutions distributing")

alertcondition(bullOBCondition and bullOBStrength >= 4, title="ğŸ“¦ NEW BULL OB", message="ğŸ“¦ NEW BULLISH ORDER BLOCK {{ticker}}")
alertcondition(bearOBCondition and bearOBStrength >= 4, title="ğŸ“¦ NEW BEAR OB", message="ğŸ“¦ NEW BEARISH ORDER BLOCK {{ticker}}")

alertcondition(validBullFVG, title="ğŸ“¦ NEW BULL FVG", message="ğŸŸ© NEW BULLISH FVG {{ticker}}")
alertcondition(validBearFVG, title="ğŸ“¦ NEW BEAR FVG", message="ğŸŸ¥ NEW BEARISH FVG {{ticker}}")

alertcondition(ifvgBull, title="ğŸ”„ BULL IFVG", message="ğŸ”„ BULLISH IFVG {{ticker}} | Bearish FVG reclaimed")
alertcondition(ifvgBear, title="ğŸ”„ BEAR IFVG", message="ğŸ”„ BEARISH IFVG {{ticker}} | Bullish FVG reclaimed")

alertcondition(londonStart, title="LONDON OPEN", message="London Session Open")
alertcondition(nyStart, title="NY OPEN", message="NY Session Open")
alertcondition(powerHourStart, title="POWER HOUR", message="Power Hour Open")

alertcondition(longSignal or shortSignal, title="ğŸ¯ ANY SNIPER SIGNAL", message="ğŸ¯ SNIPER SIGNAL {{ticker}} @ {{close}}")

alertcondition(longSignal and longConfluence >= minScoreExcellent, title="â­ EXCELLENT LONG", message="â­ EXCELLENT LONG {{ticker}} @ {{close}} | Top-tier setup!")
alertcondition(shortSignal and shortConfluence >= minScoreExcellent, title="â­ EXCELLENT SHORT", message="â­ EXCELLENT SHORT {{ticker}} @ {{close}} | Top-tier setup!")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  END OF INDICATOR  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
