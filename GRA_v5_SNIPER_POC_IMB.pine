// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0
// Â© Alexandro Disla - Get Rich Aggressively v5 SNIPER
// Precision Futures Scalping | NQ â€¢ ES â€¢ YM â€¢ GC â€¢ BTC
// SNIPER MODE + POC & IMBALANCES: Quality over quantity

//@version=6
indicator("GRA v5 SNIPER + POC/IMB", shorttitle="GRA5ğŸ¯", overlay=true, max_labels_count=500, max_boxes_count=500, max_lines_count=500)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  INSTRUMENT AUTO-DETECTION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var float ticksPerPoint = 4.0
var float tickValue = 0.25
var string instrumentType = "NQ"

if str.contains(str.upper(syminfo.ticker), "NQ") or str.contains(str.upper(syminfo.ticker), "MNQ")
    ticksPerPoint := 4.0
    tickValue := 0.25
    instrumentType := "NQ"
else if str.contains(str.upper(syminfo.ticker), "ES") or str.contains(str.upper(syminfo.ticker), "MES")
    ticksPerPoint := 4.0
    tickValue := 0.25
    instrumentType := "ES"
else if str.contains(str.upper(syminfo.ticker), "YM") or str.contains(str.upper(syminfo.ticker), "MYM")
    ticksPerPoint := 1.0
    tickValue := 1.0
    instrumentType := "YM"
else if str.contains(str.upper(syminfo.ticker), "GC") or str.contains(str.upper(syminfo.ticker), "MGC")
    ticksPerPoint := 10.0
    tickValue := 0.10
    instrumentType := "GC"
else if str.contains(str.upper(syminfo.ticker), "BTC")
    ticksPerPoint := 1.0
    tickValue := 5.0
    instrumentType := "BTC"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  CONFIGURATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string GRP_TIER = "â•â•â•â•â•â•â•â•â•â•â• TIER THRESHOLDS â•â•â•â•â•â•â•â•â•â•â•"
float sTierPoints = input.float(100.0, "S-Tier (Points)", minval=10, maxval=500, step=10, group=GRP_TIER,
     tooltip="100+ pts = Institutional move, HOLD LONGER")
float aTierPoints = input.float(50.0, "A-Tier (Points)", minval=5, maxval=100, step=5, group=GRP_TIER,
     tooltip="50-99 pts = Strong move, HOLD A BIT")
float bTierPoints = input.float(20.0, "B-Tier (Points)", minval=5, maxval=50, step=5, group=GRP_TIER,
     tooltip="20-49 pts = Quick scalp, CLOSE FAST")

string GRP_SNIPER = "â•â•â•â•â•â•â•â•â•â•â• SNIPER FILTERS â•â•â•â•â•â•â•â•â•â•â•"
float minVolRatio = input.float(1.5, "Min Volume Ratio", minval=1.0, maxval=3.0, step=0.1, group=GRP_SNIPER,
     tooltip="Volume must be 1.5x average minimum")
float deltaThreshold = input.float(0.60, "Delta Dominance %", minval=0.55, maxval=0.80, step=0.01, group=GRP_SNIPER,
     tooltip="60%+ = Clear buyer/seller control")
float bodyRatio = input.float(0.70, "Min Body Ratio", minval=0.5, maxval=0.9, step=0.05, group=GRP_SNIPER,
     tooltip="Body must be 70%+ of candle range")
float rangeMultiplier = input.float(1.3, "Min Range vs Avg", minval=1.0, maxval=2.0, step=0.1, group=GRP_SNIPER,
     tooltip="Candle range must be 1.3x average")
bool requireCVDConfirm = input.bool(true, "Require CVD Confirmation", group=GRP_SNIPER,
     tooltip="CVD direction must match signal")
string analysisTimeframe = input.timeframe("1", "Intrabar TF", group=GRP_SNIPER)

string GRP_SESSION = "â•â•â•â•â•â•â•â•â•â•â• SESSION SETTINGS â•â•â•â•â•â•â•â•â•â•â•"
bool onlyKeySession = input.bool(true, "Only Signal in Key Sessions", group=GRP_SESSION)
string sessionTimezone = input.string("America/New_York", "Timezone", 
     options=["America/New_York", "America/Chicago", "Europe/London", "UTC"], group=GRP_SESSION)
string londonWindow = input.string("0300-0500", "London Window", group=GRP_SESSION)
string nyWindow = input.string("0930-1130", "NY Window", group=GRP_SESSION)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  POC & IMBALANCE CONFIG  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string GRP_POC = "â•â•â•â•â•â•â•â•â•â•â• POC SETTINGS â•â•â•â•â•â•â•â•â•â•â•"
bool showPOC = input.bool(true, "Show POC", group=GRP_POC, tooltip="Point of Control - highest volume price level per candle")
bool pocOnlyTiered = input.bool(true, "POC Only on Tiered Candles", group=GRP_POC, tooltip="Only show POC on B-tier or higher candles")
bool pocOnlySession = input.bool(false, "POC Only in Sessions", group=GRP_POC, tooltip="Only show POC during London/NY")
int pocResolution = input.int(10, "POC Price Bins", minval=5, maxval=30, step=1, group=GRP_POC, tooltip="Number of price levels to analyze (higher = more precision)")
color pocColor = input.color(color.new(#FFD700, 0), "POC Color (Gold)", group=GRP_POC)
int pocLookback = input.int(50, "POC Display Count", minval=10, maxval=200, step=10, group=GRP_POC, tooltip="Number of recent POC markers to display")

string GRP_IMB = "â•â•â•â•â•â•â•â•â•â•â• IMBALANCE SETTINGS â•â•â•â•â•â•â•â•â•â•â•"
bool showImbalances = input.bool(true, "Show Imbalances", group=GRP_IMB, tooltip="Areas of buy/sell dominance")
float imbRatio = input.float(2.5, "Min Imbalance Ratio", minval=1.5, maxval=5.0, step=0.1, group=GRP_IMB, tooltip="Buy must be 2.5x sell (or vice versa) to qualify")
int minStackedLevels = input.int(2, "Min Stacked Levels", minval=1, maxval=5, step=1, group=GRP_IMB, tooltip="Minimum consecutive imbalance levels")
bool imbOnlySession = input.bool(true, "Imbalances Only in Sessions", group=GRP_IMB, tooltip="Only show imbalances during London/NY (SNIPER mode)")
float imbVolFilter = input.float(1.3, "Min Volume for Imbalance", minval=1.0, maxval=2.0, step=0.1, group=GRP_IMB, tooltip="Volume must be 1.3x average to show imbalance")
color bullImbColor = input.color(color.new(#00E676, 60), "Bullish Imbalance (Green)", group=GRP_IMB)
color bearImbColor = input.color(color.new(#FF5252, 60), "Bearish Imbalance (Red)", group=GRP_IMB)
int imbLookback = input.int(30, "Imbalance Display Count", minval=10, maxval=100, step=5, group=GRP_IMB, tooltip="Number of recent imbalances to display")

string GRP_VISUAL = "â•â•â•â•â•â•â•â•â•â•â• COLORS â•â•â•â•â•â•â•â•â•â•â•"
color sTierColor = input.color(color.new(#FFD700, 0), "S-Tier (Gold)", group=GRP_VISUAL)
color aTierColor = input.color(color.new(#00E676, 0), "A-Tier (Green)", group=GRP_VISUAL)
color bTierColor = input.color(color.new(#FFC107, 0), "B-Tier (Yellow)", group=GRP_VISUAL)
color longColor = input.color(color.new(#00E676, 0), "Long", group=GRP_VISUAL)
color shortColor = input.color(color.new(#FF5252, 0), "Short", group=GRP_VISUAL)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  CANDLE STRUCTURE  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float bodyHigh = math.max(open, close)
float bodyLow = math.min(open, close)
float bodySize = bodyHigh - bodyLow
float candleRange = high - low
float upperWick = high - bodyHigh
float lowerWick = bodyLow - low

float candlePoints = candleRange / tickValue / ticksPerPoint

bool isBullish = close > open
bool isBearish = close < open

float avgRange = ta.sma(candleRange, 20)
float avgVol = ta.sma(volume, 20)
float volRatio = avgVol > 0 ? volume / avgVol : 1.0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  SNIPER QUALITY FILTERS  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float currentBodyRatio = candleRange > 0 ? bodySize / candleRange : 0
bool hasStrongBody = currentBodyRatio >= bodyRatio
bool hasSignificantRange = candleRange >= avgRange * rangeMultiplier
bool hasVolume = volRatio >= minVolRatio

bool bullWickOK = isBullish ? (upperWick < bodySize * 0.5) : true
bool bearWickOK = isBearish ? (lowerWick < bodySize * 0.5) : true
bool wicksOK = bullWickOK and bearWickOK

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  TIER CLASSIFICATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string tier = candlePoints >= sTierPoints ? "S" : candlePoints >= aTierPoints ? "A" : candlePoints >= bTierPoints ? "B" : "X"
bool isTiered = tier != "X"
bool isTierS = tier == "S"
bool isTierA = tier == "A"
bool isTierB = tier == "B"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  SESSION DETECTION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool inLondon = not na(time(timeframe.period, londonWindow, sessionTimezone))
bool inNY = not na(time(timeframe.period, nyWindow, sessionTimezone))
bool inSession = inLondon or inNY
bool sessionOK = onlyKeySession ? inSession : true

bool londonStart = na(time(timeframe.period, londonWindow, sessionTimezone)[1]) and inLondon and timeframe.isintraday
bool nyStart = na(time(timeframe.period, nyWindow, sessionTimezone)[1]) and inNY and timeframe.isintraday

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  INTRABAR ANALYSIS - DELTA, POC & IMBALANCES  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// User Defined Types for cleaner state management
type VolumeProfile
    array<float> priceLevels
    array<float> buyVolumes
    array<float> sellVolumes

type Imbalance
    float priceTop
    float priceBottom
    bool isBullish
    int barIdx

var float buyVol = 0.0
var float sellVol = 0.0
var float cvd = 0.0
var float currentPOC = na
var array<Imbalance> imbalances = array.new<Imbalance>()

// Arrays to store POC and Imbalance visualization
var array<line> pocLines = array.new<line>()
var array<box> imbBoxes = array.new<box>()

if timeframe.isintraday
    [ltfO, ltfC, ltfV, ltfH, ltfL] = request.security_lower_tf(syminfo.tickerid, analysisTimeframe, [open, close, volume, high, low])
    
    if array.size(ltfC) > 0
        float tBuy = 0.0
        float tSell = 0.0
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // VOLUME PROFILE CALCULATION FOR POC
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Create price bins for volume profile
        float priceStep = candleRange / pocResolution
        array<float> binVolumes = array.new_float(pocResolution, 0.0)
        array<float> binBuyVol = array.new_float(pocResolution, 0.0)
        array<float> binSellVol = array.new_float(pocResolution, 0.0)
        
        // Process each intrabar candle
        for i = 0 to array.size(ltfC) - 1
            float ltfRange = array.get(ltfH, i) - array.get(ltfL, i)
            float ltfClose = array.get(ltfC, i)
            float ltfOpen = array.get(ltfO, i)
            float ltfVol = array.get(ltfV, i)
            float ltfLow = array.get(ltfL, i)
            
            // Calculate buy/sell for this bar
            float buyPctCalc = 0.5
            if ltfRange > 0
                buyPctCalc := (ltfClose - ltfLow) / ltfRange
            else
                buyPctCalc := ltfClose >= ltfOpen ? 1.0 : 0.0
            
            float barBuy = buyPctCalc * ltfVol
            float barSell = (1 - buyPctCalc) * ltfVol
            
            tBuy += barBuy
            tSell += barSell
            
            // Assign volume to price bins
            // Find which bin this candle belongs to (based on VWAP of the intrabar candle)
            float ltfVWAP = (array.get(ltfH, i) + array.get(ltfL, i) + ltfClose) / 3
            int binIdx = priceStep > 0 ? math.floor((ltfVWAP - low) / priceStep) : 0
            binIdx := math.max(0, math.min(binIdx, pocResolution - 1))
            
            array.set(binVolumes, binIdx, array.get(binVolumes, binIdx) + ltfVol)
            array.set(binBuyVol, binIdx, array.get(binBuyVol, binIdx) + barBuy)
            array.set(binSellVol, binIdx, array.get(binSellVol, binIdx) + barSell)
        
        buyVol := tBuy
        sellVol := tSell
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FIND POC (HIGHEST VOLUME BIN)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        float maxVol = 0.0
        int pocBinIdx = 0
        for j = 0 to pocResolution - 1
            if array.get(binVolumes, j) > maxVol
                maxVol := array.get(binVolumes, j)
                pocBinIdx := j
        
        // Calculate POC price (center of the bin)
        currentPOC := low + (pocBinIdx + 0.5) * priceStep
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DETECT IMBALANCES (STACKED BUY/SELL DOMINANCE)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Check for stacked imbalances
        int bullStackCount = 0
        int bearStackCount = 0
        int bullStackStart = -1
        int bearStackStart = -1
        int bullStackEnd = -1
        int bearStackEnd = -1
        
        for k = 0 to pocResolution - 1
            float binBuy = array.get(binBuyVol, k)
            float binSell = array.get(binSellVol, k)
            
            // Check for bullish imbalance at this level
            bool isBullImb = binSell > 0 and (binBuy / binSell >= imbRatio)
            bool isBearImb = binBuy > 0 and (binSell / binBuy >= imbRatio)
            
            // Handle zero denominators
            if binSell == 0 and binBuy > 0
                isBullImb := true
            if binBuy == 0 and binSell > 0
                isBearImb := true
            
            // Track bullish stacks
            if isBullImb
                if bullStackCount == 0
                    bullStackStart := k
                bullStackCount += 1
                bullStackEnd := k
            else
                // Check if we have a valid stack
                if bullStackCount >= minStackedLevels
                    // Record this bullish imbalance zone
                    Imbalance newImb = Imbalance.new()
                    newImb.priceBottom := low + bullStackStart * priceStep
                    newImb.priceTop := low + (bullStackEnd + 1) * priceStep
                    newImb.isBullish := true
                    newImb.barIdx := bar_index
                    array.push(imbalances, newImb)
                bullStackCount := 0
                bullStackStart := -1
            
            // Track bearish stacks
            if isBearImb
                if bearStackCount == 0
                    bearStackStart := k
                bearStackCount += 1
                bearStackEnd := k
            else
                // Check if we have a valid stack
                if bearStackCount >= minStackedLevels
                    // Record this bearish imbalance zone
                    Imbalance newImb = Imbalance.new()
                    newImb.priceBottom := low + bearStackStart * priceStep
                    newImb.priceTop := low + (bearStackEnd + 1) * priceStep
                    newImb.isBullish := false
                    newImb.barIdx := bar_index
                    array.push(imbalances, newImb)
                bearStackCount := 0
                bearStackStart := -1
        
        // Handle stacks that end at the last bin
        if bullStackCount >= minStackedLevels
            Imbalance newImb = Imbalance.new()
            newImb.priceBottom := low + bullStackStart * priceStep
            newImb.priceTop := low + (bullStackEnd + 1) * priceStep
            newImb.isBullish := true
            newImb.barIdx := bar_index
            array.push(imbalances, newImb)
        
        if bearStackCount >= minStackedLevels
            Imbalance newImb = Imbalance.new()
            newImb.priceBottom := low + bearStackStart * priceStep
            newImb.priceTop := low + (bearStackEnd + 1) * priceStep
            newImb.isBullish := false
            newImb.barIdx := bar_index
            array.push(imbalances, newImb)

else
    // Fallback for non-intraday
    float rng = high - low
    if rng > 0
        float buyPctEst = (close - low) / rng
        buyVol := buyPctEst * volume
        sellVol := (1 - buyPctEst) * volume
    else
        if close >= open
            buyVol := volume
            sellVol := 0
        else
            sellVol := volume
            buyVol := 0
    currentPOC := (high + low + close) / 3  // Simple VWAP estimate

// Update CVD
float barDelta = buyVol - sellVol
cvd := cvd + barDelta

float totalVol = buyVol + sellVol
float buyPct = totalVol > 0 ? buyVol / totalVol : 0.5
float sellPct = totalVol > 0 ? sellVol / totalVol : 0.5

// STRICT delta dominance
bool buyDominant = buyPct >= deltaThreshold
bool sellDominant = sellPct >= deltaThreshold

// CVD trend confirmation
float cvdMA = ta.sma(cvd, 5)
bool cvdBullish = cvd > cvdMA
bool cvdBearish = cvd < cvdMA

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  SNIPER SIGNAL GENERATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool confirmedLong = isBullish and buyDominant
bool confirmedShort = isBearish and sellDominant

bool cvdConfirmLong = not requireCVDConfirm or cvdBullish
bool cvdConfirmShort = not requireCVDConfirm or cvdBearish

bool longSignal = isTiered and hasVolume and confirmedLong and hasStrongBody and hasSignificantRange and wicksOK and cvdConfirmLong and sessionOK
bool shortSignal = isTiered and hasVolume and confirmedShort and hasStrongBody and hasSignificantRange and wicksOK and cvdConfirmShort and sessionOK

bool sLong = longSignal and isTierS
bool aLong = longSignal and isTierA
bool bLong = longSignal and isTierB

bool sShort = shortSignal and isTierS
bool aShort = shortSignal and isTierA
bool bShort = shortSignal and isTierB

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  POC VISUALIZATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Determine if we should show POC on this candle
bool showPOCThisBar = showPOC
if pocOnlyTiered
    showPOCThisBar := showPOCThisBar and isTiered
if pocOnlySession
    showPOCThisBar := showPOCThisBar and inSession

// Draw POC marker
if showPOCThisBar and not na(currentPOC) and barstate.isconfirmed
    // Create a small horizontal line at POC level
    line pocLine = line.new(
         x1=bar_index, 
         y1=currentPOC, 
         x2=bar_index + 1, 
         y2=currentPOC, 
         color=pocColor, 
         width=3, 
         style=line.style_solid)
    array.push(pocLines, pocLine)
    
    // Clean up old POC lines
    if array.size(pocLines) > pocLookback
        line oldLine = array.shift(pocLines)
        line.delete(oldLine)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  IMBALANCE VISUALIZATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Volume filter for imbalances
bool imbVolOK = volRatio >= imbVolFilter
bool imbSessionOK = imbOnlySession ? inSession : true

// Draw imbalances from the array
if showImbalances and imbVolOK and imbSessionOK and barstate.isconfirmed
    // Process any new imbalances from this bar
    int imbSize = array.size(imbalances)
    if imbSize > 0
        // Only draw imbalances from current bar
        for idx = 0 to math.min(imbSize - 1, 10)  // Limit to 10 per bar max
            if idx < array.size(imbalances)
                Imbalance imb = array.get(imbalances, idx)
                if imb.barIdx == bar_index
                    color imbCol = imb.isBullish ? bullImbColor : bearImbColor
                    box imbBox = box.new(
                         left=bar_index - 1, 
                         top=imb.priceTop, 
                         right=bar_index + 2, 
                         bottom=imb.priceBottom, 
                         bgcolor=imbCol, 
                         border_color=color.new(imbCol, -20), 
                         border_width=1)
                    array.push(imbBoxes, imbBox)

// Clean up old imbalance boxes
if array.size(imbBoxes) > imbLookback
    box oldBox = array.shift(imbBoxes)
    box.delete(oldBox)

// Clean up old imbalances from array (keep only recent)
if array.size(imbalances) > 200
    array.shift(imbalances)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  VISUALIZATION  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

color tierCol = isTierS ? sTierColor : isTierA ? aTierColor : isTierB ? bTierColor : na

// Long Signals - Only SNIPER quality
plotshape(sLong, "S Long", shape.triangleup, location.belowbar, sTierColor, size=size.normal, text="SğŸ¯", textcolor=color.white)
plotshape(aLong, "A Long", shape.triangleup, location.belowbar, aTierColor, size=size.small, text="AğŸ¯", textcolor=color.white)
plotshape(bLong, "B Long", shape.triangleup, location.belowbar, bTierColor, size=size.tiny, text="BğŸ¯", textcolor=color.white)

// Short Signals - Only SNIPER quality
plotshape(sShort, "S Short", shape.triangledown, location.abovebar, sTierColor, size=size.normal, text="SğŸ¯", textcolor=color.white)
plotshape(aShort, "A Short", shape.triangledown, location.abovebar, aTierColor, size=size.small, text="AğŸ¯", textcolor=color.white)
plotshape(bShort, "B Short", shape.triangledown, location.abovebar, bTierColor, size=size.tiny, text="BğŸ¯", textcolor=color.white)

// Session Markers
plotshape(londonStart, "LDN", shape.diamond, location.abovebar, color.new(#2196F3, 0), size=size.tiny, text="L", textcolor=color.white)
plotshape(nyStart, "NY", shape.diamond, location.abovebar, color.new(#4CAF50, 0), size=size.tiny, text="N", textcolor=color.white)

// Session backgrounds
bgcolor(inLondon ? color.new(#2196F3, 96) : na, title="London BG")
bgcolor(inNY ? color.new(#4CAF50, 96) : na, title="NY BG")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  INFO TABLE  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var table panel = table.new(position.top_right, 2, 10, bgcolor=color.new(color.black, 10), border_width=1, border_color=color.new(#333333, 0))

if barstate.islast
    // Header
    table.cell(panel, 0, 0, "GRA5", text_color=color.white, text_size=size.small, bgcolor=color.new(#FFD700, 30))
    table.cell(panel, 1, 0, "ğŸ¯" + instrumentType, text_color=color.white, text_size=size.small, bgcolor=color.new(#FFD700, 30))
    
    // Points & Tier
    table.cell(panel, 0, 1, "Pts", text_color=color.white, text_size=size.tiny)
    table.cell(panel, 1, 1, str.tostring(candlePoints, "#.#"), text_color=tierCol, text_size=size.tiny)
    
    table.cell(panel, 0, 2, "Tier", text_color=color.white, text_size=size.tiny)
    table.cell(panel, 1, 2, tier, text_color=tierCol, text_size=size.tiny)
    
    // Volume
    color vCol = hasVolume ? color.green : color.red
    table.cell(panel, 0, 3, "Vol", text_color=color.white, text_size=size.tiny)
    table.cell(panel, 1, 3, str.tostring(volRatio, "#.#") + "x", text_color=vCol, text_size=size.tiny)
    
    // Delta
    string dStr = buyPct > sellPct ? str.tostring(buyPct * 100, "#") + "%B" : str.tostring(sellPct * 100, "#") + "%S"
    color dCol = buyDominant ? longColor : sellDominant ? shortColor : color.white
    table.cell(panel, 0, 4, "Delta", text_color=color.white, text_size=size.tiny)
    table.cell(panel, 1, 4, dStr, text_color=dCol, text_size=size.tiny)
    
    // Body Ratio
    color bCol = hasStrongBody ? color.green : color.red
    table.cell(panel, 0, 5, "Body", text_color=color.white, text_size=size.tiny)
    table.cell(panel, 1, 5, str.tostring(currentBodyRatio * 100, "#") + "%", text_color=bCol, text_size=size.tiny)
    
    // CVD
    string cvdDir = cvdBullish ? "â–²" : "â–¼"
    color cvdCol = cvdBullish ? longColor : shortColor
    table.cell(panel, 0, 6, "CVD", text_color=color.white, text_size=size.tiny)
    table.cell(panel, 1, 6, cvdDir, text_color=cvdCol, text_size=size.tiny)
    
    // Session
    string sStr = inNY ? "NY!" : inLondon ? "LDN!" : "---"
    color sCol = inSession ? color.yellow : color.gray
    table.cell(panel, 0, 7, "Sess", text_color=color.white, text_size=size.tiny)
    table.cell(panel, 1, 7, sStr, text_color=sCol, text_size=size.tiny)
    
    // POC Price
    table.cell(panel, 0, 8, "POC", text_color=color.white, text_size=size.tiny)
    table.cell(panel, 1, 8, str.tostring(currentPOC, format.mintick), text_color=pocColor, text_size=size.tiny)
    
    // Imbalance Count (recent)
    int recentImbCount = 0
    for imb in imbalances
        if imb.barIdx >= bar_index - 10
            recentImbCount += 1
    string imbStr = recentImbCount > 0 ? str.tostring(recentImbCount) : "-"
    color imbDispCol = recentImbCount > 0 ? color.yellow : color.gray
    table.cell(panel, 0, 9, "IMB", text_color=color.white, text_size=size.tiny)
    table.cell(panel, 1, 9, imbStr, text_color=imbDispCol, text_size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  ALERTS  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

alertcondition(sLong, title="ğŸ¯ S-TIER LONG", message="ğŸ¯ğŸ¥‡ SNIPER S-TIER LONG {{ticker}} @ {{close}}")
alertcondition(aLong, title="ğŸ¯ A-TIER LONG", message="ğŸ¯ğŸ¥ˆ SNIPER A-TIER LONG {{ticker}} @ {{close}}")
alertcondition(bLong, title="ğŸ¯ B-TIER LONG", message="ğŸ¯ğŸ¥‰ SNIPER B-TIER LONG {{ticker}} @ {{close}}")

alertcondition(sShort, title="ğŸ¯ S-TIER SHORT", message="ğŸ¯ğŸ¥‡ SNIPER S-TIER SHORT {{ticker}} @ {{close}}")
alertcondition(aShort, title="ğŸ¯ A-TIER SHORT", message="ğŸ¯ğŸ¥ˆ SNIPER A-TIER SHORT {{ticker}} @ {{close}}")
alertcondition(bShort, title="ğŸ¯ B-TIER SHORT", message="ğŸ¯ğŸ¥‰ SNIPER B-TIER SHORT {{ticker}} @ {{close}}")

alertcondition(londonStart, title="LONDON OPEN", message="London Open - {{ticker}}")
alertcondition(nyStart, title="NY OPEN", message="NY Open - {{ticker}}")

if longSignal or shortSignal
    string t = tier
    string d = longSignal ? "LONG" : "SHORT"
    string act = isTierS ? "HOLD" : isTierA ? "SWING" : "SCALP"
    string deltaInfo = longSignal ? str.tostring(buyPct * 100, "#") + "%B" : str.tostring(sellPct * 100, "#") + "%S"
    string pocInfo = " | POC: " + str.tostring(currentPOC, format.mintick)
    alert("ğŸ¯ GRA5 " + t + "-" + d + " | " + syminfo.ticker + " @ " + str.tostring(close, format.mintick) + " | " + deltaInfo + pocInfo + " | " + act, alert.freq_once_per_bar_close)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  END OF INDICATOR  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
